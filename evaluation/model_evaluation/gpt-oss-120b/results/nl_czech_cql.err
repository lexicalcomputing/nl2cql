'Najdi lemmata končící na -nost\tpreloaded/cstenten23_mj2\t[lemma=".*nost"]\n'
On line 1
[lemma=".*nost"]
'Najdi přesně středník\tpreloaded/cstenten23_mj2\t[word==";"]\n'
On line 2
[word==";"]
'Pětipísmenná malá slova\tpreloaded/cstenten23_mj2\t[word="[[:lower:]]{5}"]\n'
On line 3
[lc=".{5}"]
'Slova začínající na pře-\tpreloaded/cstenten23_mj2\t[lc="pře.*"]\n'
On line 4
[word="pře.*"]
'Slova končící na -ový nebo -ová\tpreloaded/cstenten23_mj2\t[word=".*ov[ýá]"]\n'
On line 5
[word=".*(ový|ová)"]
'Lemmata začínající mikro- a končící -skop\tpreloaded/cstenten23_mj2\t[lemma="mikro.*skop"]\n'
On line 6
[lemma="mikro.*skop"]
'Slovo začínající s velkým písmenem uvnitř věty, ne však na začátku\tpreloaded/cstenten23_mj2\t[][word="[[:upper:]].+"] within <s/>\n'
On line 7
<s/> []{1,} [word="[A-Z].*"]
'Tokeny s pomlčkou\tpreloaded/cstenten23_mj2\t[word=".*-.*"]\n'
On line 8
[word=".*-.*"]
'Tokeny složené jen z číslic\tpreloaded/cstenten23_mj2\t[word="\\d+"]\n'
On line 9
[word="[0-9]+"]
'Tokeny složené jen z interpunkce s více jak jedním znakem\tpreloaded/cstenten23_mj2\t[word="[[:punct:]]{2,}"]\n'
On line 10
[tag="kI.*" & word=".{2,}"]
'Vlastní jména\tpreloaded/cstenten23_mj2\t[tag="k1.*" & word="[[:upper:]].*"]\n'
On line 11
[tag="k1.*" & word="[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ].*"]
'Zájmena tázací/relativní\tpreloaded/cstenten23_mj2\t[tag="k3.*" & word="kdo|co|který|jenž"]\n'
On line 12
[tag="k3.*(yQ|yR).*"]
'Příslovce zakončená na -ě\tpreloaded/cstenten23_mj2\t[word=".*ě" & tag="k6.*"]\n'
On line 13
[tag="k6.*" & word=".*ě"]
'Přídavná jména v 1. stupni\tpreloaded/cstenten23_mj2\t[tag="k2.*d1.*"]\n'
On line 14
[tag="k2.*d1.*"]
'Přídavná jména v 2. stupni\tpreloaded/cstenten23_mj2\t[tag="k2.*d2.*"]\n'
On line 15
[tag="k2.*d2.*"]
'Přídavná jména v 3. stupni\tpreloaded/cstenten23_mj2\t[tag="k2.*d3.*"]\n'
On line 16
[tag="k2.*d3.*"]
'Spojka "a"\tpreloaded/cstenten23_mj2\t[word=="a" & tag="k8.*"]\n'
On line 17
[ word="a" & tag="k8.*" ]
'Slova ten, tento, tamhleten\tpreloaded/cstenten23_mj2\t[word="ten|tento|tamhleten"]\n'
On line 18
[lemma="ten|tento|tamhleten"]
'Pluralia v -i\tpreloaded/cstenten23_mj2\t[word=".*i" & tag="k1.*nP.*"]\n'
On line 19
[tag="k1.*nP.*" & word=".*i"]
'Podstatná jména v 6. pádě\tpreloaded/cstenten23_mj2\t[tag="k1.*c6.*"]\n'
On line 20
[tag="k1.*c7.*"]
'Podstatná jména v 7. pádě\tpreloaded/cstenten23_mj2\t[tag="k1.*c7.*"]\n'
On line 21
[tag="k1.*c7.*"]
'Tokeny s apostrofem\tpreloaded/cstenten23_mj2\t[word=".*\'.*"]\n'
On line 22
[word=".*'.*"]
'Měnové symboly Kč/€/$\tpreloaded/cstenten23_mj2\t[word="Kč|€|\\$"]\n'
On line 23
[word="(Kč|€|\\$)"]
'Domény končící na .cz\tpreloaded/cstenten23_mj2\t[word=".*\\.cz"]\n'
On line 24
<doc urldomain=".*\.cz"/>
'Hex barvy\tpreloaded/cstenten23_mj2\t[word="#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})"]\n'
On line 25
[word="#[0-9A-Fa-f]{3,6}"]
'Uživatelská jména začínající @\tpreloaded/cstenten23_mj2\t[word="@\\w+"]\n'
On line 26
[word="@.*"]
'Hashtagy\tpreloaded/cstenten23_mj2\t[word="#\\w+"]\n'
On line 27
[word="#.*"]
'URL končící .pdf\tpreloaded/cstenten23_mj2\t[word="https?://.+\\.pdf"]\n'
On line 28
<doc url=".*\.pdf"/>
'Symbol © nebo ® jako c nebo r v závorkách\tpreloaded/cstenten23_mj2\t[word=="("][word="[cCrR]"][word==")"]\n'
On line 29
([word="©"] | [word="®"]) |([word="("][lc="c"][word=")"] | [word="("][lc="r"][word=")"])
'Římské číslice I–X\tpreloaded/cstenten23_mj2\t[word="I|II|III|IV|V|VI|VII|VIII|IX|X"]\n'
On line 30
[word="I|II|III|IV|V|VI|VII|VIII|IX|X"]
'Čísla s desetinnou tečkou\tpreloaded/cstenten23_mj2\t[word="\\d+\\.\\d+"]\n'
On line 31
[ tag="k4.*" & word="[0-9]+\\.[0-9]+" ]
'Procenta s číslem\tpreloaded/cstenten23_mj2\t[word="\\d+(\\.\\d+)?%"]\n'
On line 32
([tag="k4.*"][word="%"]) | ([tag="k4.*"][lemma="procent"])
'Název měsíce následovaný rokem\tpreloaded/cstenten23_mj2\t[word="Leden|Únor|Březen|Duben|Květen|Červen|Červenec|Srpen|Září|Říjen|Listopad|Prosinec"][word="\\d{4}"]\n'
On line 33
[lemma="leden|únor|březen|duben|květen|červen|červenec|srpen|září|říjen|listopad|prosinec" & tag="k1.*"] [tag="k4.*" & word="[0-9]{4}"]
'Den v týdnu následovaný čárkou\tpreloaded/cstenten23_mj2\t[word="Pondělí|Úterý|Středa|Čtvrtek|Pátek|Sobota|Neděle"][word==","]\n'
On line 34
[lemma="(pondělí|úterý|středa|čtvrtek|pátek|sobota|neděle)"] [word=","]
'Čas ve formátu HH:MM nebo HH.MM.\tpreloaded/cstenten23_mj2\t[word="[012]?[0-9][:\\.][0-5][0-9]"]\n'
On line 35
[word="[0-9]{2}[:\\.][0-9]{2}"]
'Věta začínající uvozovkou\tpreloaded/cstenten23_mj2\t<s> [word="\\"|„|‚|“|’|\'"]\n'
On line 36
<s/> [word="(\"|„|“)"]
'Věta končící vykřičníkem\tpreloaded/cstenten23_mj2\t[word=="!"] </s>\n'
On line 37
<s/> []{0,}[word="!"] </s>
'Chci všechny výskyty otevřené závorky\tpreloaded/cstenten23_mj2\t[word=="("]\n'
On line 38
[word=="("]
'Výskyty zavírací závorky\tpreloaded/cstenten23_mj2\t[word==")"]\n'
On line 39
[word=")"]
'Obsah v závorkách do 20 tokenů\tpreloaded/cstenten23_mj2\t[word=="("][]{0,20}[word==")"] within <s/>\n'
On line 40
[word="\\("] []{0,20} [word="\\)"]
'Úsek v uvozovkách do 12 tokenů\tpreloaded/cstenten23_mj2\t[word="\\"|„|‚|“|’|\'"][word!="\\"|„|‚|“|’|\'"]{0,12}[word="\\"|„|‚|“|’|\'"] within <s/>\n'
On line 41
[word="\""] []{0,12} [word="\""]
'"Pan/Paní" před jménem\tpreloaded/cstenten23_mj2\t[word="Pan|Paní"][tag="k1.*" & word="[[:upper:]].*"]\n'
On line 42
[lemma="Pan|Paní"] [word="[A-Z][A-Za-z]*"]
'Zájmeno + být\tpreloaded/cstenten23_mj2\t[tag="k3.*"][lemma="být"]\n'
On line 43
[tag="k3.*"][lemma="být"]
'Podst. jméno s jedním předcházejícím adj.\tpreloaded/cstenten23_mj2\t[tag="k2.*"][tag="k1.*"]\n'
On line 44
[tag="k2.*"] [tag="k1.*"]
'Podst. jméno se dvěma adjektivy před\tpreloaded/cstenten23_mj2\t[tag="k2.*"]{2}[tag="k1.*"]\n'
On line 45
[tag="k2.*"] [tag="k2.*"] [tag="k1.*"]
'Podst. jméno s 0-3 adjektivy před\tpreloaded/cstenten23_mj2\t[tag="k2.*"]{0,3}[tag="k1.*"]\n'
On line 46
[tag="k2.*"]{0,3}[tag="k1.*"]
'Příslovce těsně před adjektivem\tpreloaded/cstenten23_mj2\t[tag="k6.*"][tag="k2.*"]\n'
On line 47
[tag="k6.*"] [tag="k2.*"]
'Adjektivum těsně před slovesem\tpreloaded/cstenten23_mj2\t[tag="k2.*"][tag="k5.*"]\n'
On line 48
[tag="k2.*"][tag="k5.*"]
'Sloveso těsně před podst. jménem\tpreloaded/cstenten23_mj2\t[tag="k5.*"][tag="k1.*"]\n'
On line 49
[tag="k5.*"][tag="k1.*"]
'Zájméno + adjektivum + podstatné jméno\tpreloaded/cstenten23_mj2\t[tag="k3.*"][tag="k2.*"][tag="k1.*"]\n'
On line 50
[tag="k3.*"] [tag="k2.*"] [tag="k1.*"]
'Dvě vlastní jména za sebou\tpreloaded/cstenten23_mj2\t[tag="k1.*" & word="[[:upper:]].*"]{2}\n'
On line 51
[ tag="k1.*" & word="[A-Z].*" ] [ tag="k1.*" & word="[A-Z].*" ]
'Tři vlastní jména za sebou\tpreloaded/cstenten23_mj2\t[tag="k1.*" & word="[[:upper:]].*"]{3}\n'
On line 52
[ tag="k1.*" & word="[A-Z].*" ] [ tag="k1.*" & word="[A-Z].*" ] [ tag="k1.*" & word="[A-Z].*" ]
'Tři po sobě jdoucí podst. jména\tpreloaded/cstenten23_mj2\t[tag="k1.*"]{3}\n'
On line 53
[tag="k1.*"] [tag="k1.*"] [tag="k1.*"]
'Sloveso + částice s <= 2 tokeny\tpreloaded/cstenten23_mj2\t[tag="k5.*"][]{0,2}[tag="k9.*"]\n'
On line 54
[tag="k5.*"] []{0,2}[word="s"]
'Sloveso + příslovce + částice\tpreloaded/cstenten23_mj2\t[tag="k5.*"][tag="k6.*"][tag="k9.*"]\n'
On line 55
[tag="k5.*"][tag="k6.*"][tag="k9.*"]
'Modál + token + infinitiv\tpreloaded/cstenten23_mj2\t[tag="k6.*tD.*"][][tag="k5.*mF.*"]\n'
On line 56
[lemma="(muset|moci|smět|chtít|dovolit|potřebovat)"] [] [tag="k5.*mF.*"]
'"chtít" + "to" + infinitiv\tpreloaded/cstenten23_mj2\t[lemma="chtít"][lemma="to"][tag="k5.*mF.*"]\n'
On line 57
[lemma="chtít"][lemma="to"][tag="k5.*mF.*"]
'"potřebovat" + "to" + infinitiv\tpreloaded/cstenten23_mj2\t[lemma="potřebovat"][lemma="to"][tag="k5.*mF.*"]\n'
On line 58
[lemma="potřebovat"] [word="to"] [tag="k5.*mF.*"]
'"zkusit" + "to" + infinitiv\tpreloaded/cstenten23_mj2\t[lemma="zkusit"][lemma="to"][tag="k5.*mF.*"]\n'
On line 59
[lemma="zkusit"][word="to"][tag="k5.*mF.*"]
'"začít" + přechodník\tpreloaded/cstenten23_mj2\t[lemma="začít"][tag="k5.*(mS|mD).*"]\n'
On line 60
[lemma="začít" & tag="k5.*m[SD].*"]
'"přestat" + přechodník\tpreloaded/cstenten23_mj2\t[lemma="přestat"][tag="k5.*(mS|mD).*"]\n'
On line 61
[lemma="přestat" & (tag="k5.*mS.*" | tag="k5.*mD.*")]
'"být" + "schopen" + infinitiv\tpreloaded/cstenten23_mj2\t[lemma="být"][lemma="schopen"][tag="k5.*mF.*"]\n'
On line 62
[lemma="být"][lemma="schopen"][tag="k5.*mF.*"]
'"mohl by" + infinitiv\tpreloaded/cstenten23_mj2\t[word=="mohl"][word=="by"][tag="k5.*mF.*"]\n'
On line 63
[lemma="moci"] [word="by"] [tag="k5.*mF.*"]
'"raději by" + infinitiv\tpreloaded/cstenten23_mj2\t[word=="raději"][word=="by"][tag="k5.*mF.*"]\n'
On line 64
[lemma="raději"] [word="by"] [tag="k5.*mF.*"]
'"nejlépe" + infinitiv\tpreloaded/cstenten23_mj2\t[word=="nejlépe"][tag="k5.*mF.*"]\n'
On line 65
[lemma="nejlépe"] [tag="k5.*mF.*"]
'k2 + k1 + k5\tpreloaded/cstenten23_mj2\t[tag="k2.*"][tag="k1.*"][tag="k5.*"]\n'
On line 66
[tag="k2.*"] [tag="k1.*"] [tag="k5.*"]
'„pokusit se“ + infinitiv\tpreloaded/cstenten23_mj2\t[lemma="pokusit"][lemma="se"][tag="k5.*mF.*"]\n'
On line 67
[lemma="pokusit"][lc="se"][tag="k5.*mF.*"]
'„snažit se“ + infinitiv\tpreloaded/cstenten23_mj2\t[lemma="snažit"][lemma="se"][tag="k5.*mF.*"]\n'
On line 68
[lemma="snažit"][lemma="se"][tag="k5.*mF"]
'"být" do 1 tokenu od slovesa\tpreloaded/cstenten23_mj2\t(meet [lemma="být"] [tag="k5.*"] -1 1)\n'
On line 69
(meet [lemma="být"] [tag="k5.*"] -1 1)
'Sloveso do 3 tokenů od "riziko"\tpreloaded/cstenten23_mj2\t(meet [tag="k5.*"] [lemma="riziko"] -3 3)\n'
On line 70
(meet [tag="k5.*"] [lemma="riziko"] -3 3)
'Adjektivum do 2 tokenů od "zdát"\tpreloaded/cstenten23_mj2\t(meet [tag="k2.*"] [lemma="zdát"] -2 2)\n'
On line 71
(meet [tag="k2.*"] [lemma="zdát"] -2 2)
'Podstatné jméno do 5 tokenů od "růst"\tpreloaded/cstenten23_mj2\t(meet [tag="k1.*"] [lemma="růst"] -5 5)\n'
On line 72
(meet [tag="k1.*"] [lemma="růst"] -5 5)
'Sloveso nebo přídavné jméno poblíž "být"\tpreloaded/cstenten23_mj2\t(union (meet [tag="k5.*"] [lemma="být"] -3 3) (meet [tag="k2.*"] [lemma="být"] -3 3))\n'
On line 73
(meet [tag="k5.*|k2.*"] [lemma="být"] -3 3)
'"tak (přídavné jméno) jako" ve větě\tpreloaded/cstenten23_mj2\t[word="tak"][tag="k2.*"][word="jako"] within <s/>\n'
On line 74
[lemma="tak" & tag="k2.*"] []{0,3} [lemma="jako"]
'„tak <přídavné jméno> že“ do 3 tokenů\tpreloaded/cstenten23_mj2\t[word="tak"][tag="k2.*"][word="že"] within []{6}\n'
On line 75
[word="tak"][tag="k2.*"][word="že"]
'"příliš [přídavné jméno] na to" + infinitiv\tpreloaded/cstenten23_mj2\t[word="příliš"][tag="k2.*"][word="na"][word="to"][tag="k5.*mF.*"]\n'
On line 76
[word="příliš"] [tag="k2.*"] [word="na"] [word="to"] [tag="k5.*mF.*"]
'"dost <podstatné jméno>"\tpreloaded/cstenten23_mj2\t[word="dost"][tag="k1.*"]\n'
On line 77
[word="dost"][tag="k1.*"]
'"velmi <přídavné jméno>"\tpreloaded/cstenten23_mj2\t[word="velmi"][tag="k2.*"]\n'
On line 78
[lemma="velmi"] [tag="k2.*"]
'"více/méně [přídavné jméno]"\tpreloaded/cstenten23_mj2\t[word="více|méně"][tag="k2.*"]\n'
On line 79
([word="více" & tag="k2.*"]) | ([word="méně" & tag="k2.*"])
'"více (podstatné jméno) než (podstatné jméno)"\tpreloaded/cstenten23_mj2\t[word="více"][tag="k1.*"][word="než"][tag="k1.*"]\n'
On line 80
[lemma="více"] [tag="k1.*"] [lemma="než"] [tag="k1.*"]
'"nejvíce\\nejméně (sloveso)"\tpreloaded/cstenten23_mj2\t[word="nejvíce|nejméně"][tag="k5.*"]\n'
On line 81
([lemma="nejvíce" & tag="k5.*"]) | ([lemma="nejméně" & tag="k5.*"])
'Frazém "co nejdříve"\tpreloaded/cstenten23_mj2\t[word="co"][word="nejdříve"]\n'
On line 82
[word="co"][word="nejdříve"]
'Frazém "tak jako tak"\tpreloaded/cstenten23_mj2\t[word="tak"][word="jako"][word="tak"]\n'
On line 83
[word="tak"][word="jako"][word="tak"]
'"<podstatné jméno> na <podstatné jméno>"\tpreloaded/cstenten23_mj2\t[tag="k1.*"][lemma="na"][tag="k1.*"]\n'
On line 84
[tag="k1.*"][lemma="na"][tag="k1.*"]
'"<podstatné jméno> versus <podstatné jméno>"\tpreloaded/cstenten23_mj2\t[tag="k1.*"][word=="vs\\\\.|versus|proti"][tag="k1.*"]\n'
On line 85
[tag="k1.*"][word="versus"][tag="k1.*"]
'"protože" + cokoliv\tpreloaded/cstenten23_mj2\t[lemma="protože"][]\n'
On line 86
[ word="protože" ] []
'"ačkoliv" + libovolný token\tpreloaded/cstenten23_mj2\t[lemma="ačkoliv"][]\n'
On line 87
[word="ačkoliv"] []
'"zatímco" + cokoliv\tpreloaded/cstenten23_mj2\t[lemma="zatímco"][]\n'
On line 88
[ word="zatímco" ] [ ]
'Části "od té doby co" v korpusu\tpreloaded/cstenten23_mj2\t[word="od"][word="té"][word="doby"][word="co"]\n'
On line 89
[word="od"][word="té"][word="doby"][word="co"]
'Infinitivy po "aby"\tpreloaded/cstenten23_mj2\t[word="aby"][tag="k5.*mF.*"]\n'
On line 90
[lemma="aby"] [tag="k5.*mF.*"]
'Infinitivy před "aby"\tpreloaded/cstenten23_mj2\t[tag="k5.*mF.*"][word="aby"]\n'
On line 91
[tag="k5.*mF.*"] [word="aby"]
'Fráze "tam je / je tam"\tpreloaded/cstenten23_mj2\t([word="tam"][word="je"]|[word="je"][word="tam"])\n'
On line 92
([word="tam"][word="je"]) | ([word="je"][word="tam"])
'"to" + lemma "být" + přídavné jméno\tpreloaded/cstenten23_mj2\t[word="to"][lemma="být"][tag="k2.*"]\n'
On line 93
[word="to"][lemma="být"][tag="k2.*"]
'Věta, která je otázka\tpreloaded/cstenten23_mj2\t<s/> containing [word=="?"] </s>\n'
On line 94
<s/> containing [word="\\?"]
'Věta bez čárky\tpreloaded/cstenten23_mj2\t<s/> !containing [word==","]\n'
On line 95
<s/> !containing [word=","]
'Věta s dvojtečkou\tpreloaded/cstenten23_mj2\t<s/> containing [word==":"]\n'
On line 96
<s/> containing [word=":"]
'Věta se středníkem\tpreloaded/cstenten23_mj2\t<s/> containing [word==";"]\n'
On line 97
<s/> containing [word=";"]
'Věta nezačínající velkým písmenem\tpreloaded/cstenten23_mj2\t<s/> containing <s> [word="[[:upper:]].+"]\n'
On line 98
<s> [!word="[A-Z].*"]
'Věta začíná příslovcem a čárkou\tpreloaded/cstenten23_mj2\t<s/> containing <s> [tag="k6.*"][word==","]\n'
On line 99
<s/> [tag="k6.*"] [word=","]
'Odstavec obsahující rok\tpreloaded/cstenten23_mj2\t<p/> containing [word="\\d{4}"]\n'
On line 100
<p/> containing [word="[0-9]{4}"]
'Odstavec bez číslic\tpreloaded/cstenten23_mj2\t<p/> !containing [word=".*\\d.*"]\n'
On line 101
<p/> !containing [word="[0-9]+"]
'Dokument s tématem koníčky\tpreloaded/cstenten23_mj2\t<doc topic=".*hobbies.*" />\n'
On line 102
<doc topic="koníčky"/>
'Dokument typu zpravodajství\tpreloaded/cstenten23_mj2\t<doc genre=".*news.*" />\n'
On line 103
<doc genre="zpravodajství"/>
'"Brno" v dokumentech obsahující "Morava" v názvu\tpreloaded/cstenten23_mj2\t[word="Brno"] within <doc title=".*Morava.*"/>\n'
On line 104
<doc title=".*Morava.*">[word="Brno"]
'"Fakulta Informatiky" v dokumentech obsahující "Masaryk" v názvu\tpreloaded/cstenten23_mj2\t[word="Fakulta"][word="Informatiky"] within <doc title=".*Masaryk.*"/>\n'
On line 105
<doc title=".*Masaryk.*"> [word="Fakulta"][word="Informatiky"]
'Podst. jména v odstavcích které byli získány v roce 2017\tpreloaded/cstenten23_mj2\t[tag="k1.*"] within <doc crawl_date=".*2017.*"/>\n'
On line 106
<doc crawl_year="2017"> [tag="k1.*"] within <p/>
'Věty uvnitř dokumentů s tématem "technologie"\tpreloaded/cstenten23_mj2\t<s/> within <doc topic=".*technology.*"/>\n'
On line 107
<doc topic="technologie"> <s/> containing [word=".*"]
'Věty bez velkých písmen\tpreloaded/cstenten23_mj2\t<s/> !containing [word="[[:upper:]]+"]\n'
On line 108
<s/> !containing [word="[A-Z][A-Za-z]*"]
'Uvozovky bez podst. jména (<=8 tok.)\tpreloaded/cstenten23_mj2\t[word="\\"|„|‚|“|’|\'"][word!="\\"|„|‚|“|’|\'" & tag!="k1.*"]{0,8}[word="\\"|„|‚|“|’|\'"] within <s/>\n'
On line 109
(  [word="„"] [tag!="k1.*"]{0,8} [word="“"]) |(  [word="\""] [tag!="k1.*"]{0,8} [word="\""])
'"klimatická změna" v jedné větě\tpreloaded/cstenten23_mj2\t[lemma="klimatický"][lemma="změna"] within <s/>\n'
On line 110
[word="klimatická"][word="změna"] within <s/>
'"data-driven" vs "data driven"\tpreloaded/cstenten23_mj2\t[word=="data-driven"] | [word="data"][word="driven"] within <s/>\n'
On line 111
([word="data-driven"]) | ([word="data"][word="driven"])
'"na jedné straně ... na druhé straně"\tpreloaded/cstenten23_mj2\t[word="na"][word="jedné"][word="straně"][]{1,8}[word="na"][word="druhé"][word="straně"]\n'
On line 112
[lemma="na"][lemma="jeden"][lemma="strana"] []{0,20} [lemma="na"][lemma="druhý"][lemma="strana"]
'Opakovaný bigram A B do 6 tokenů\tpreloaded/cstenten23_mj2\t1:[] 2:[] []{0,6} 3:[] 4:[] & 1.word=3.word & 2.word=4.word\n'
On line 113
1:[] 2:[] []{0,2} 3:[] 4:[] & 1.lemma=3.lemma & 2.lemma=4.lemma
1:[] 2:[] []{0,2} 3:[] 4:[] & (1.lemma = 3.lemma & 2.lemma = 4.lemma)
1:[] 2:[] []{0,2} 3:[] 4:[] & 1.lemma=3.lemma & 2.lemma=4.lemma
1:[] 2:[] []{0,2} 3:[] 4:[] & 1.word=3.word & 2.word=4.word
'Dvě identická slova vedle sebe\tpreloaded/cstenten23_mj2\t1:[] 2:[] & 1.word = 2.word\n'
On line 114
1:[] 2:[] & 1.word = 2.word
1:[] 2:[] & 1.lc = 2.lc
1:[] 2:[] & 1.word == 2.word
1:[] 2:[]&1.word=2.word
'Dva sousední tokeny se stejným lemmatem\tpreloaded/cstenten23_mj2\t1:[] 2:[] & 1.lemma = 2.lemma\n'
On line 115
1:[] 2:[] & 1.lemma = 2.lemma
[lemma=".*"] [lemma=".*"] & 1.lemma = 2.lemma
1:[lemma=".*"] 2:[lemma=".*"] & 1.lemma = 2.lemma
1:[] 2:[] & 1.lemma == 2.lemma
'Přídavná. jména se stejným lemmatem spojená spojkou\tpreloaded/cstenten23_mj2\t1:[tag="k2.*"][tag="k8.*"] 2:[tag="k2.*"] & 1.lemma = 2.lemma\n'
On line 116
1:[tag="k2.*"] 2:[tag="k8.*"] 3:[tag="k2.*"] & 1.lemma = 3.lemma
1:[tag="k2.*"] 2:[tag="k8.*"] 3:[tag="k2.*"]&1.lemma=3.lemma
1:[tag="k2.*"] 2:[tag="k8.*"] 3:[tag="k2.*"] & 1.lemma = 3.lemma
1:[tag="k2.*"] 2:[tag="k8.*"] 3:[tag="k2.*"] & 1.lemma=3.lemma
'Podst. jména s různým lemmatem spojená spojkou\tpreloaded/cstenten23_mj2\t1:[tag="k1.*"][tag="k8.*"] 2:[tag="k1.*"] & 1.lemma != 2.lemma\n'
On line 117
1:[tag="k1.*"] 2:[tag="k8.*"] 3:[tag="k1.*"] & 1.lemma != 3.lemma
1:[tag="k1.*"] 2:[tag="k8.*"] 3:[tag="k1.*"] & (1.lemma != 3.lemma)
1:[tag="k1.*"] 2:[tag="k8.*"] 3:[tag="k1.*"] & 1.lemma != 3.lemma
1:[tag='k1.*'] 2:[tag='k8.*'] 3:[tag='k1.*'] & 1.lemma != 3.lemma
'Adjektivum bez následného podst. jména\tpreloaded/cstenten23_mj2\t[tag="k2.*"][tag!="k1.*"]\n'
On line 118
[tag="k2.*"] [tag!="k1.*"]
'„přítomný“ nikoli sloveso\tpreloaded/cstenten23_mj2\t[word=="přítomný" & !tag="k5.*"]\n'
On line 119
[lemma="přítomný" & !tag="k5.*"]
'\'objekt\' jako podst. jméno, ne sloveso\tpreloaded/cstenten23_mj2\t[lemma=="objekt" & tag="k1.*"]\n'
On line 120
[lemma="objekt" & tag="k1.*"]
'"záznam" jen jako podst. jméno\tpreloaded/cstenten23_mj2\t[lemma="záznam" & tag="k1.*"]\n'
On line 121
[ lemma="záznam" & tag="k1.*" ]
'"číst" jen jako sloveso\tpreloaded/cstenten23_mj2\t[lemma="číst" & tag="k5.*"]\n'
On line 122
[lemma="číst" & tag="k5.*"]
'Varianty pravopisu "e-mail/email"\tpreloaded/cstenten23_mj2\t[word="e-?mail"]\n'
On line 123
[word="e-?mail"]
'Varianty „kooperovat/co-operate“\tpreloaded/cstenten23_mj2\t[lemma="ko-?operovat"]\n'
On line 124
[lemma="kooperovat"] | [lemma="co-operate"]
'Varianty "re-kreace/rekreace"\tpreloaded/cstenten23_mj2\t[word="re-?kreace"]\n'
On line 125
[lemma="rekreace" | lemma="re-kreace"]
'Varianty \'well-being/wellbeing\'\tpreloaded/cstenten23_mj2\t[word="well-?being"]\n'
On line 126
[lemma="well-being" | lemma="wellbeing"]
'"zdravotní péče/healthcare"\tpreloaded/cstenten23_mj2\t[word="zdravotní"][word="péče"] | [word="healthcare"]\n'
On line 127
([lemma="zdravotní"][lemma="péče"]) | [word="healthcare"]
'Praha bez ohledu na velikost písmen\tpreloaded/cstenten23_mj2\t[lc="praha"]\n'
On line 128
[lc="praha"]
'Česká republika bez ohledu na velikost\tpreloaded/cstenten23_mj2\t[lc="česká"][lc="republika"]\n'
On line 129
[lc="česká"][lc="republika"]
'Adjektiva končící -ální\tpreloaded/cstenten23_mj2\t[lemma=".*ální" & tag="k2.*"]\n'
On line 130
[lemma=".*ální" & tag="k2.*"]
'Slovesa končící -ovat\tpreloaded/cstenten23_mj2\t[lemma=".*ovat" & tag="k5.*"]\n'
On line 131
[tag="k5.*" & word=".*ovat"]
'Podst. jména končící -ce\tpreloaded/cstenten23_mj2\t[lemma=".*ce" & tag="k1.*"]\n'
On line 132
[ tag="k1.*" & word=".*ce" ]
'Slova začínající mikro-\tpreloaded/cstenten23_mj2\t[word="mikro.*"]\n'
On line 133
[word="mikro.*"]
'Slova končící -ologie\tpreloaded/cstenten23_mj2\t[word=".*ologie"]\n'
On line 134
[lemma=".*ologie"]
'Jen malá písmena\tpreloaded/cstenten23_mj2\t[word="[[:lower:]]+"]\n'
On line 135
[word="[a-z]+"]
'Jen velká písmena\tpreloaded/cstenten23_mj2\t[word="[[:upper:]]+"]\n'
On line 136
[word="[A-Z]+"]
'"US" nebo "U.S." regex\tpreloaded/cstenten23_mj2\t[word="US|U\\.S\\."]\n'
On line 137
[word="U\\.?S\\.?"]
'Token není tečka\tpreloaded/cstenten23_mj2\t[word!="\\."]\n'
On line 138
[word!="."]
'Lexikograficky >= „m“\tpreloaded/cstenten23_mj2\t[word>="m"]\n'
On line 139
[lemma_lc>="m"]
'Lexikograficky < „m“\tpreloaded/cstenten23_mj2\t[word<"m"]\n'
On line 140
[word="[a-l].*"]
'Slovesa v dokumentech téma=věda\tpreloaded/cstenten23_mj2\t[tag="k5.*"] within <doc topic=="science"/>\n'
On line 141
<tag="k5.*"> within <doc topic="věda"/>
[tag="k5.*"] within <doc topic="věda"/>
'Věty bez číslic\tpreloaded/cstenten23_mj2\t<s/> !containing [word=".*\\d.*"]\n'
On line 142
<s/> !containing [word=".*[0-9].*"]
'Tezaurus: zelenina po "krájet" do 0–2\tpreloaded/cstenten23_mj2\t[lemma="krájet"][]{0,2} ~"mrkev-n"\n'
On line 143
[lemma="krájet"] []{0,2} ~"zelenina-n"
[lemma="krájet"] []{0,2} ~15"zelenina-n"
'Tezaurus: 20 podobných k "město-n"\tpreloaded/cstenten23_mj2\t~20"město-n"\n'
On line 144
~20"město-n"
'"investovat" následováno slovy podobnými "obnovitelný" do vzdálenosti 3\tpreloaded/cstenten23_mj2\t[lemma="investovat"][]{0,3} ~"obnovitelný-j"\n'
On line 145
[lemma="investovat"] []{0,3} ~"obnovitelný"
[lemma="investovat"] []{0,3} [lemma="obnovit.*"]
'12 slov podobných slovu „lékař-n“ do vzdálenosti 2 od slovesa kontaktovat\tpreloaded/cstenten23_mj2\t(meet ~12"lékař-n" [lemma="kontaktovat"] -5 5)\n'
On line 146
(meet ~"lékař-n" [lemma="kontaktovat"] -2 2)
(meet ~12"lékař-n" [lemma="kontaktovat"] -2 2)
'Slova podobná podst. jménu "emise" ve vzdálenosti +-5 od lemma "snížit"\tpreloaded/cstenten23_mj2\t(meet ~"emise-n" [lemma="snížit"] -5 5)\n'
On line 147
(meet ~"emise-n" [lemma="snížit"] -5 5)
(meet [lemma="snížit"] ~"emise-n" -5 5)
meet [lemma="snížit"] ~"emise-n" -5 5
(meet ~"emise-n" [lemma="snížit"] -5 5)
'Podst. jméno do 2 tokenů od adjektiva\tpreloaded/cstenten23_mj2\t(meet [tag="k1.*"] [tag="k2.*"] -2 2)\n'
On line 148
(meet [tag="k1.*"] [tag="k2.*"] -2 2)
'Sloveso 1–4 tokeny vpravo od podst. jména\tpreloaded/cstenten23_mj2\t(meet [tag="k5.*"] [tag="k1.*"] 1 4)\n'
On line 149
(meet [tag="k5.*"] [tag="k1.*"] -4 -1)
'Adjektiva 2–5 tokenů vlevo od podst. jmen\tpreloaded/cstenten23_mj2\t(meet [tag="k2.*"] [tag="k1.*"] -5 -2)\n'
On line 150
(meet [tag="k2.*"] [tag="k1.*"] -5 -2)
'podst. jména u "byl/byla" a příd. jména u lemma "být". Obojí se vzdáleností +-2.\tpreloaded/cstenten23_mj2\t(union (meet [tag="k1.*"] [word=="byl|byla"] -2 2) (meet [tag="k2.*"] [lemma="být"] -2 2))\n'
On line 151
(union  (meet [tag="k1.*"] [word="byl|byla"] -2 2)  (meet [tag="k2.*"] [lemma="být"] -2 2))
'Rok v závorkách\tpreloaded/cstenten23_mj2\t[word=="("][word="\\d{4}"][word==")"]\n'
On line 152
[word="("][word="[0-9]{4}"][word=")"]
'Tokeny jen z pomlček\tpreloaded/cstenten23_mj2\t[word="-+"]\n'
On line 153
[word="[-]+"]
'Čárky uvnitř závorek\tpreloaded/cstenten23_mj2\t[word==","] within ([word=="("][]*[word==")"])\n'
On line 154
[tag="kI.*x\\("] []* [tag="kI.*x,"] []* [tag="kI.*x\\)"]
'Vlastní jméno + rok\tpreloaded/cstenten23_mj2\t[tag="k1.*" & word="[[:upper:]].*"][word="\\d{4}"]\n'
On line 155
[tag="k1.*" & word="[A-Z].*"][tag="k4.*" & word="\d{4}"]
'"Prosím" + infinitiv\tpreloaded/cstenten23_mj2\t[word=="[Pp]rosím"][tag="k5.*mF.*"]\n'
On line 156
[lc="prosím"][tag="k5.*mF.*"]
'"Mohl bys" + infinitiv\tpreloaded/cstenten23_mj2\t[word=="[Mm]ohl"][word=="bys|by"][tag="k5.*mF.*"]\n'
On line 157
[lc="mohl"] [lc="bys"] [tag="k5.*mF.*"]
'"Rád bych" + infinitiv\tpreloaded/cstenten23_mj2\t[word=="[Rr]ád"][word=="bych"][tag="k5.*mF.*"]\n'
On line 158
[lemma="rad"] [lemma="být"] [tag="k5.*mF.*"]
'"tak aby"\tpreloaded/cstenten23_mj2\t[word=="tak"][word=="aby"]\n'
On line 159
[lc="tak"][lc="aby"]
'"v případě že"\tpreloaded/cstenten23_mj2\t[word=="v"][word=="případě"][word=="že"]\n'
On line 160
[word="v"][word="případě"][word="že"]
'Slova psaná velkými písmeny\tpreloaded/cstenten23_mj2\t[word="[[:upper:]]+"]\n'
On line 161
[word="^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$"]
'Slova s českou diakritikou\tpreloaded/cstenten23_mj2\t[word=".*[áéíóúůýčďěňřšťž].*"]\n'
On line 162
[word=".*[áčďéěíňóřšťúůýžÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ].*"]
'Číslovky v textu\tpreloaded/cstenten23_mj2\t[tag="k4.*"]\n'
On line 163
[tag="k4.*"]
'Interpunkce kromě tečky\tpreloaded/cstenten23_mj2\t[tag="kI.*" & word!="\\."]\n'
On line 164
[tag="kI.*" & !word="."]
'Podst. jména 1. pád sg.\tpreloaded/cstenten23_mj2\t[tag="k1.*nS.*c1.*"]\n'
On line 165
[tag="k1.*nS.*c1.*"]
'Výpustky\tpreloaded/cstenten23_mj2\t[word=="..."]\n'
On line 166
[lemma="výpustka"]
'Zkratky\tpreloaded/cstenten23_mj2\t[tag="kA.*"]\n'
On line 167
[tag="kA.*"]
'Slova s pomlčkou/spojovníkem\tpreloaded/cstenten23_mj2\t[word=".*[-–].*"]\n'
On line 168
[word=".*-.*"]
'Slova příbuzná k "věřit"\tpreloaded/cstenten23_mj2\t[lemma="věřit"]\n'
On line 169
[lemma="věřit"]
'Předložky v korpusu\tpreloaded/cstenten23_mj2\t[tag="k7.*"]\n'
On line 170
[tag="k7.*"]
'Příslovce\tpreloaded/cstenten23_mj2\t[tag="k6.*"]\n'
On line 171
[tag="k6.*"]
'Slovo na pozici 1000\tpreloaded/cstenten23_mj2\t[#1000]\n'
On line 172
1000:[]
'Slovo na první pozici\tpreloaded/cstenten23_mj2\t[#0]\n'
On line 173
<s/> []
'Slovo na pozici 7831\tpreloaded/cstenten23_mj2\t[#7831]\n'
On line 174
[pos="7831"]
'Dvě sousední se stejným tagem\tpreloaded/cstenten23_mj2\t1:[] 2:[] & 1.tag = 2.tag\n'
On line 175
1:[] 2:[] & 1.tag = 2.tag
(1:[] 2:[]) & 1.tag = 2.tag
1:[] 2:[] & (1.tag = 2.tag)
1: [] 2: [] & 1.tag = 2.tag
'Dva sousední, identické tokeny\tpreloaded/cstenten23_mj2\t1:[] 2:[] & 1.word = 2.word\n'
On line 176
1:[] 2:[] & 1.word = 2.word
(1:[] 2:[]) & 1.word = 2.word
1:[] 2:[] & 1.lc = 2.lc
1:[word=".*"] 2:[word=".*"] & 1.word = 2.word
'Dvě slova ve větě se stejným lemmatem\tpreloaded/cstenten23_mj2\t(1:[] 2:[] within <s/>) & 1.lemma = 2.lemma\n'
On line 177
1:[] []{0,5} 2:[] & 1.lemma = 2.lemma within <s/>
1:[ ] [ ]{0,5} 2:[ ] & 1.lemma = 2.lemma within <s/>
1:[] []{0,5} 2:[] within <s/> & 1.lemma = 2.lemma
[ ] []{0,5} [ ] & 1.lemma = 2.lemma within <s/>
'Dvě slova se stejným lemmatem a žádné není číslovka\tpreloaded/cstenten23_mj2\t(1:[tag!="k4.*"] 2:[tag!="k4.*"] within <s/>) & 1.lemma = 2.lemma\n'
On line 178
1:[] 2:[] & 1.lemma = 2.lemma & 1.tag != "k4.*" & 2.tag != "k4.*" within <s/>
1:[] []{0,} 2:[] within <s/> & 1.lemma = 2.lemma & 1.tag != "k4.*" & 2.tag != "k4.*"
1:[] []{0,10} 2:[] within <s/> & 1.lemma = 2.lemma & 1.tag != "k4.*" & 2.tag != "k4.*"
1:[] 2:[] within <s/> & 1.lemma = 2.lemma & 1.tag != "k4.*" & 2.tag != "k4.*"
'Čtyřslovná sekvence: 1.=2. tag, 1.=4. lemma\tpreloaded/cstenten23_mj2\t1:[] 2:[] [] 3:[] & 1.tag = 2.tag & 1.lemma = 3.lemma\n'
On line 179
1:[] 2:[] 3:[] 4:[] & 1.tag = 2.tag & 1.lemma = 4.lemma
1:[] 2:[] 3:[] 4:[] & (1.tag = 2.tag) & (1.lemma = 4.lemma)
1:[] 2:[] 3:[] 4:[] &1.tag=2.tag &1.lemma=4.lemma
1:[] 2:[] 3:[] 4:[] & 1.tag = 2.tag & 1.lemma = 4.lemma
'Ve větě sloveso následující po podstatném jménu, které má stejné lemma jako sloveso\tpreloaded/cstenten23_mj2\t(1:[tag="k1.*"]2:[tag="k5.*"] within <s/>) & 1.lemma = 2.lemma\n'
On line 180
1:[tag="k1.*"] 2:[tag="k5.*"] & 1.lemma = 2.lemma
1:[tag="k1.*"] 2:[tag="k5.*"] & 1.lemma = 2.lemma
(1:[tag="k1.*"] 2:[tag="k5.*"]) & 1.lemma = 2.lemma
1:[tag="k1.*"] 2:[tag="k5.*"] & 1.lemma_lc = 2.lemma_lc
'Dvě přídavná jména + podstatné jméno s f(1)>100000 a f(2)<5000\tpreloaded/cstenten23_mj2\t1:[tag="k2.*"]2:[tag="k2.*"][tag="k1.*"] & f(1.word)>100000 & f(2.word)<5000\n'
On line 181
1:[tag="k2.*"] 2:[tag="k2.*"] 3:[tag="k1.*"] & f(1.word)>100000 & f(2.word)<5000
'Dvě sousední slova se stejným lemmatem, ale různým zápisem\tpreloaded/cstenten23_mj2\t1:[]2:[] & 1.lemma = 2.lemma & 1.word != 2.word\n'
On line 182
1:[] 2:[] & 1.lemma = 2.lemma & 1.word != 2.word
1:[word] 2:[word] & 1.lemma = 2.lemma & 1.word != 2.word
1:[lemma=".*"] 2:[lemma=".*"] & 1.lemma = 2.lemma & 1.word != 2.word
1:[] 2:[] & 1.lemma = 2.lemma & 1.word != 2.word
'Dvě sousední slova, jedno má frekvenci > 2e7\tpreloaded/cstenten23_mj2\t1:[]2:[] & (f(1.word)>20000000 | f(2.word)>20000000)\n'
On line 183
1:[] 2:[] & (f(1.word)>20000000 | f(2.word)>20000000)
'Slovo "úraz" na doméně ulekare.cz\tpreloaded/cstenten23_mj2\t[word="úraz"] within <doc urldomain=="ulekare.cz"/>\n'
On line 184
<doc urldomain="ulekare.cz">[lemma="úraz"]</doc>
'\'agrese\' v dokumentech s tématem hry\tpreloaded/cstenten23_mj2\t[lemma="agrese"] within <doc topic="games"/>\n'
On line 185
<doc topic="hry">[lemma="agrese"]
'"agrese" v tématech hry nebo vzdělání\tpreloaded/cstenten23_mj2\t[lemma="agrese"] within <doc topic="education|games"/>\n'
On line 186
(<doc topic="hry">[lemma="agrese"]) | (<doc topic="vzdělání">[lemma="agrese"])
'"reklama" na blozích\tpreloaded/cstenten23_mj2\t[lemma="reklama"] within <doc genre=".*blog.*"/>\n'
On line 187
<doc genre="blog">[lemma="reklama"]
'"Barack Obama" v dokumentech s titulkem obsahujícím "skandál"\tpreloaded/cstenten23_mj2\t[word="Barack"][word="Obama"] within <doc title=".*skandál.*"/>\n'
On line 188
<doc title=".*skandál.*">[word="Barack"][word="Obama"]
'Sloveso "hacknout" v dokumentech s žánrem zprávy\tpreloaded/cstenten23_mj2\t[lemma="hacknout" & tag="k5.*"] within <doc genre=".*news.*"/>\n'
On line 189
<doc genre="zprávy">[lemma="hacknout"]
'"zmrzlina" v červnu\tpreloaded/cstenten23_mj2\t[lemma="zmrzlina"] within <doc month=".+-06"/>\n'
On line 190
<doc modified_month="06">[lemma="zmrzlina"]</doc>
'Věty obsahující číslo větší než 100\tpreloaded/cstenten23_mj2\t<s/> containing [word>="101" & word="[0-9]+" & tag="k4.*"]\n'
On line 191
<s/> containing [word="[1-9][0-9]{2,}"]
'Sloveso a předložka\tpreloaded/cstenten23_mj2\t[tag="k5.*"][tag="k7.*"]\n'
On line 192
[tag="k5.*"] [tag="k7.*"]
'Spojení "tak/velmi <přídavné jméno>, že"\tpreloaded/cstenten23_mj2\t[word="tak|velmi"][tag="k2.*"][word=","][word="že"]\n'
On line 193
[word="tak|velmi"] [tag="k2.*"] [tag="kI.*" & word=","] [word="že"]
'se/si po slovese\tpreloaded/cstenten23_mj2\t[tag="k5.*"][word=="se|si"]\n'
On line 194
[tag="k5.*"][lemma="se|si"]
'"by" po slovese v příčestím minulém\tpreloaded/cstenten23_mj2\t[tag="k5.*mA.*"][word="by"]\n'
On line 195
[tag="k5.*mN.*"] [word="by"]
'Jednoslovné věty\tpreloaded/cstenten23_mj2\t<s> [tag="kI.*"]? [tag!="kI.*"]? [tag="kI.*"]? </s>\n'
On line 196
<s/> [word=".*"] </s>
'Věty začínající spojkou\tpreloaded/cstenten23_mj2\t<s/> containing <s> [tag="k8.*"]\n'
On line 197
<s> [tag="k8.*"]
'Věty bez slovesa\tpreloaded/cstenten23_mj2\t<s/> !containing [tag="k5.*"]\n'
On line 198
<s/> !containing [tag="k5.*"]
'Věty končící výpustkou\tpreloaded/cstenten23_mj2\t<s/> containing [word=="..."] </s>\n'
On line 199
<s/> []{0,} [tag="kI.*" & (word="…" | word="...")] </s>
'Sekvence tří tokenů: přídavné jméno + podstatné jméno + sloveso\tpreloaded/cstenten23_mj2\t[tag="k2.*"][tag="k1.*"][tag="k5.*"]\n'
On line 200
[tag="k2.*"] [tag="k1.*"] [tag="k5.*"]
'Dvě adjektiva za sebou\tpreloaded/cstenten23_mj2\t[tag="k2.*"][tag="k2.*"]\n'
On line 201
[tag="k2.*"][tag="k2.*"]
'Dvě stejná adjektiva za sebou uvnitř jedné věty\tpreloaded/cstenten23_mj2\t(1:[tag="k2.*"] 2:[tag="k2.*"] within <s/>) & 1.word = 2.word\n'
On line 202
<s/> 1:[] 2:[] & 1.tag="k2.*" & 2.tag="k2.*" & 1.lemma=2.lemma
<s/> 1:[tag="k2.*"] 2:[tag="k2.*"] & 1.lemma=2.lemma
1:[tag="k2.*"] 2:[tag="k2.*"] & 1.lemma=2.lemma within <s/>
1:[tag="k2.*"] 2:[tag="k2.*"] within <s/> & 1.lemma=2.lemma
'Sloveso následované zájmenem\tpreloaded/cstenten23_mj2\t[tag="k5.*"][tag="k3.*"]\n'
On line 203
[tag="k5.*"] [tag="k3.*"]
'První token věty\tpreloaded/cstenten23_mj2\t<s> []\n'
On line 204
<s/> [ ]
'Jednoslovná otázka\tpreloaded/cstenten23_mj2\t<s> [tag!="kI.*"] [word=="?"] </s>\n'
On line 205
<s>[tag=".*yQ.*"] [tag="kI.*"]?</s>
'Najdi přirovnání začínající „jako“ (např. „rychlý jako blesk“).\tpreloaded/ententen21_tt31\t[tag="J.*"] [lemma="like"] [tag="DT"]? [tag="N.*"] within <s/>\n'
On line 206
[word="like"] []{0,5}[tag="N.*"]
'"neboť" uvnitř věty\tpreloaded/cstenten23_mj2\t[lemma="neboť"] within <s/>\n'
On line 207
[] [word="neboť"] within <s/>
'"který" následovaný čárkou\tpreloaded/cstenten23_mj2\t[lemma="který"][word=","]\n'
On line 208
[lemma="který"] [word=","]
'Word Sketch: modifikátory „škola-n“\tpreloaded/cstenten23_mj2\t[ws("škola-n","modifiers of \\\\\\"%w\\\\\\"",".*")]\n'
On line 209
[ws("škola-n","modifiers of \"%w\"",".*")]
'Word Sketch: objekty „schválit-v“\tpreloaded/cstenten23_mj2\t[ws("schválit-v",".*objects of \\\\\\"%w\\\\\\"",".*")]\n'
On line 210
[ws("schválit-v","accusative objects of \"%w\"",".*")]
'Word Sketch: subjekty „růst-v“\tpreloaded/cstenten23_mj2\t[ws("růst-v",".*subjects of \\\\\\"%w\\\\\\"",".*")]\n'
On line 211
[ws("růst-v", "subjects of \"%w\"", ".*")]
'Word Sketch: „rozhodnutí-n“ jako objekt „učinit-v“\tpreloaded/cstenten23_mj2\t[ws("rozhodnutí-n",".*object.*","učinit-v")]\n'
On line 212
[ws("učinit-v","objects of \"%w\"","rozhodnutí-n")]
'Word Sketch: „test-n“ modifikovaný „krev-n“\tpreloaded/cstenten23_mj2\t[ws("test-n",".*modifiers of \\\\\\"%w\\\\\\"","krev-n")]\n'
On line 213
[ws("test-n", ".*modifiers of.*", "krev-n")]
'Word Sketch: relace „klima-n“ obsahující „změna“\tpreloaded/cstenten23_mj2\t[ws("klima-n",".*",".*změna.*")]\n'
On line 214
[ws("klima-n", ".*", "změna")]
'Word Sketch: předložkové vzory (o/v/na)\tpreloaded/cstenten23_mj2\t[ws("test-n","\\\\.\\\\.\\\\. (o|v|na) \\\\\\"%w\\\\\\"",".*") | ws("test-n","\\\\\\"%w\\\\\\" (o|v|na) \\\\.\\\\.\\\\.",".*")]\n'
On line 215
[ws("(o|v|na)-p", "\.\.\. (o|v|na) \"%w\"", ".*") | ws("(o|v|na)-p", "\"%w\" (o|v|na) \.\.\.", ".*")]
'Word Sketch: slovesa s %w jako subjektem\tpreloaded/cstenten23_mj2\t[ws(".*","verbs with \\\\\\"%w\\\\\\" as subject",".*-v")]\n'
On line 216
[ws(".*-v","subjects of \"%w\"",".*")]
'Word Sketch u „vládní“ v okolí 1 tokenu\tpreloaded/cstenten23_mj2\t[word=="vládní"][]{0,1}[ws("politika-n",".*",".*")]\n'
On line 217
[ws("vládní-j", ".*", ".*")]
'Tezaurus: kovy kolem \'koroze\' (+-4)\tpreloaded/cstenten23_mj2\t(meet ~"železo-n" [lemma="koroze"] -4 4)\n'
On line 218
(meet ~"metal-n" [lemma="koroze"] -4 4)
(meet [lemma="koroze"] ~"metal\-n" -4 4)
(meet [lemma="koroze"] ~"metal-n" -4 4)
( [lemma="koroze"] []{0,4} ~"metal-n" ) | ( ~"metal-n" []{0,4} [lemma="koroze"] )
'„auto“ v češtině, anglicky „car“ v paralelním segmentu\tpreloaded/europarl7_cs\t[word="auto"] within europarl7_en: [word="car"]\n'
On line 219
[word="auto"] within europarl7_en: [word="car"]
[word="auto"] within preloaded/europarl7_en: [word="car"]
[word="auto"] within europarl7_en: [word="car"]
[lemma="auto"] within europarl7_en: [lemma="car"]
'„dům“ v češtině, německy „Haus“ v paralelním segmentu\tpreloaded/europarl7_cs\t[word="dům"] within europarl7_de_1: [word="Haus"]\n'
On line 220
[word="dům"] within europarl7_de: [word="Haus"]
[word="dům"] within europarl7_de [word="Haus"]
[word="dům"] within preloaded/europarl7_de: [word="Haus"]
[word="dům"] within europarl7_de:[word="Haus"]
'Jsou slova "awfully", "horribly" a "terribly" často předcházející slovu "beautiful"?\tpreloaded/ententen21_tt31\t[word="awfully|horribly|terribly"][word="beautiful"]\n'
On line 221
[lemma="awfully" | lemma="horribly" | lemma="terribly"][lemma="beautiful"]
'Nalezni všechna slova ohraničená kulatými závorkami.\tpreloaded/ententen21_tt31\t[word=="("][word!==")"]+[word==")"]\n'
On line 222
[word="\\(.*\\)"]
'Nalezni všechna slova ohraničená závorkami.\tpreloaded/ententen21_tt31\t[word="\\(|\\[|\\{"][word!="\\)|\\]|\\}"]+[word="\\)|\\]|\\}"]\n'
On line 223
[word="("] []{1,} [word=")"]
'Prosím všechna slova, která jsou v závorkách.\tpreloaded/ententen21_tt31\t[word="\\(|\\[|\\{"][word!="\\)|\\]|\\}"]+[word="\\)|\\]|\\}"]\n'
On line 224
[word="("] []{1,} [word=")"]
'Všechna slova já v okolí +-4 slova být.\tpreloaded/ententen21_tt31\t(meet [word="I"] [lemma="be"] -4 4)\n'
On line 225
(meet [lemma="I"] [lemma="be"] -4 4)
'Najdi všechny příklady přítomného prostého času.\tpreloaded/ententen21_tt31\t[tag="VBZ|VBP|VV"] within [tag!="V.*"][tag="VBZ|VBP|VV"][tag!="V.*"]\n'
On line 226
[tag="V(BP|BZ|HP|HZ|VP|VZ)"]
'Najdi všechny přklady minulého prostého času.\tpreloaded/ententen21_tt31\t[tag="VBD|VHD|VVD"] within [tag!="V.*"][tag="VBD|VHD|VVD"][lemma="not"]?[tag!="V.*"]\n'
On line 227
[tag="V[BVH]D"]
'Najdi všechny příklady budoucího prostého času.\tpreloaded/ententen21_tt31\t[word="will" & tag="MD"][lemma="not"]?[tag!="V.*"]{0,2}[tag="VB|VH|VV"]\n'
On line 228
[lemma="will" | lemma="shall"] [tag="VB|VH|VV"]
'Najdi všechny příklady přítomného průběhového času.\tpreloaded/ententen21_tt31\t[tag="VBP|VBZ"][lemma="not"]?[tag!="V.*"]{0,2}[tag="VVG"]\n'
On line 229
[lemma="be" & tag="VBP|VBZ"] [tag="VBG"]
'Najdi všechny příklady minulého průběhového času.\tpreloaded/ententen21_tt31\t[tag="VBD"][lemma="not"]?[tag!="V.*"]{0,2}[tag="VVG|VHG|VBG"]\n'
On line 230
[lemma="be" & tag="VBD"] [tag="VBG"]
'Najdi všechny příklady budoucího průběhového času.\tpreloaded/ententen21_tt31\t[lemma="will"][lemma="not"]?[word="be"][tag="VVG|VBG|VHG"]\n'
On line 231
[tag="MD" & lemma="(will|shall)"] [word="not"]? [lemma="be" & tag="VB"] [tag="VBG"]
'Najdi všechny příklady předpřítomného prostého času.\tpreloaded/ententen21_tt31\t[tag="VH|VHZ"][lemma="not"]?[tag!="V.*"]{0,2}[tag="VVN|VBN|VHN"] within [tag!="V.*"][tag="VH|VHZ"][lemma="not"]?[tag!="V.*"]{0,2}[tag="VVN|VBN|VHN"][tag!="V.*"]\n'
On line 232
[lemma="have" & tag="VHP|VHZ"] [tag="VVN"]
'Najdi všechny příklady předminulého prostého času.\tpreloaded/ententen21_tt31\t[tag="VHD"][lemma="not"]?[tag="VBN"][tag="VVN"]\n'
On line 233
[lemma="have" & tag="VHD"] [tag="VBN|VVN"]
'Najdi všechny příklady předbudoucího prostého času.\tpreloaded/ententen21_tt31\t[word="will" & tag="MD"][lemma="not"]?[word="have"][tag="VBN|VHN|VVN"]\n'
On line 234
[ word="will" & tag="MD" ] [ lemma="have" & tag="VH" ] [ tag="V(BN|VN)" ]
'Najdi všechny příklady předpřítomného průběhového času.\tpreloaded/ententen21_tt31\t[tag="VH|VHZ|VHP"][lemma="not"]?[tag="VBN"][tag="VVG"]\n'
On line 235
[lemma="have" & tag="VHP|VHZ"] [lemma="be" & tag="VBN"] [tag="VBG"]
'Najdi všechny příklady předminulého průběhového času.\tpreloaded/ententen21_tt31\t[tag="VHD"][lemma="not"]?[tag="VBN"][tag="VVG"]\n'
On line 236
[lemma="have" & tag="VHD"] [lemma="be" & tag="VBN"] [tag="VBG"]
'Najdi všechny příklady předbudoucího průběhového času.\tpreloaded/ententen21_tt31\t[word="will" & tag="MD"][lemma="not"]?[tag="VH|VHP"][tag="VBN"][tag="VVG"]\n'
On line 237
[lemma="will" & tag="MD"] [lemma="have" & tag="VH"] [lemma="be" & tag="VBN"] [tag="VVG"]
'Věty, kde mluvčí je Andrej Babiš.\tpreloaded/parlatalk_cz\t< s/> within <speaker name=".*Andrej Babiš.*"/>\n'
On line 238
<s/> containing <speaker name="Andrej Babiš"/>
'Najdi větu s právě tolika slovy, kolik je odpovědí na otázku života, vesmíru a vůbec.\tpreloaded/ententen21_tt31\t<s> [ ]{42} </s> within <s/>\n'
On line 239
<s/> [tag!="SENT"]{42} </s>
'Potřebuji všechna frázová slovesa.\tpreloaded/ententen21_tt31\t[tag="V.*"][tag="DT|N.*|J.*"]+[tag="RP"][tag!="IN"]\n'
On line 240
[tag="V.*"] [tag="RP"]
'I need examples of prepositional verbs.\tpreloaded/ententen21_tt31\t[tag="V.*"][tag="IN"]\n'
On line 241
[tag="V.*"] [tag="IN"]
'How do I find adverbial phrases?\tpreloaded/ententen21_tt31\t[tag="IN"][tag="DT"]?[tag="J.*"]*[tag="N.*"]\n'
On line 242
[ tag="IN" ] []{0,5}[ tag="N.*" ]
'Potřebuji najít příslovečná určení. Nejen však příslovce.\tpreloaded/cstenten23_mj2\t([tag="k6.*"] | [tag="k7.*"] [tag="k1.*|k2.*|k3.*"]+) within <s/>\n'
On line 243
([tag="k6.*"])|([tag="k7.*"] []{0,2}[tag="k1.*"])|([tag="k1.*c[67].*"])
'Potřebuji nalézt všechny věty, které jsou napsané v pasivu.\tpreloaded/ententen21_tt31\t[tag="VB.*"][tag="VVN"]\n'
On line 244
<s/> containing [lemma="be" & tag="VB.*"] [tag="VBN" & lemma!="be"]
'I need to find an agent in a passive sentence.\tpreloaded/ententen21_tt31\t[tag="VB.*"][tag="VBN|VHN|VVN"][lemma!="by" & tag!="V.*"]*[lemma="by"][tag="DT"]? [tag="J.*"]*[tag="N.*"] within <s/>\n'
On line 245
[lemma="be"] [tag="VVN"] []{0,5}[word="by"] []{0,5}[tag="N.*"]
'Najdi pasivum se slovesem "get".\tpreloaded/ententen21_tt31\t[lemma="get"][tag="VVN"]\n'
On line 246
[lemma="get"] [tag="VBN"]
'I need to find all adjectives in an attributive position.\tpreloaded/ententen21_tt31\t[tag="J.*"][tag="N.*"]\n'
On line 247
[tag="DT"]? [tag="J.*"] [tag="N.*"]
'Všechny dva po sobě jdoucí tokeny se stejným tagem.\tpreloaded/ententen21_tt31\t1:[] 2:[] & 1.tag = 2.tag\n'
On line 248
1:[] 2:[] & 1.tag = 2.tag
1:[] 2:[] & 1.tag=2.tag
[tag=$t] [tag=$t]
1:[] 2:[] & 1.tag=2.tag
'Chci najít sekvenci přídavné jméno, následované podstatným jménem, kde přídavné jméno má frekvenci menší než 5000.\tpreloaded/ententen21_tt31\t1:[tag="J.*"][tag="N.*"] & f(1.word)<5000\n'
On line 249
1:[tag="J.*"] 2:[tag="N.*"] & f(1.word)<5000
'Chci nalézt sekvenci dvou po sobě jdoucích slov, která jsou stejná.\tpreloaded/ententen21_tt31\t1:[] 2:[] & 1.word = 2.word\n'
On line 250
1:[] 2:[] & 1.lc = 2.lc
1:[] 2:[] & 1.lc=2.lc
1:[] 2:[] & 1.lc = 2.lc
1:[] 2:[] & 1.word = 2.word
'Potřebuji nalézt dvě slova ve větě, která mají stejé lemma.\tpreloaded/ententen21_tt31\t(1:[] 2:[] within <s/>) & 1.lemma = 2.lemma\n'
On line 251
(1:[] []{0,10} 2:[] & 1.lemma = 2.lemma) within <s/>
1:[] []{0,10} 2:[] & 1.lemma = 2.lemma within <s/>
1:[] []{0,10} 2:[] within <s/> & 1.lemma = 2.lemma
(1:[] []{0,10} 2:[] within <s/>) & 1.lemma = 2.lemma
'Potřebuji nalézt dvě slova ve větě, která mají stejé lemma, a současně ani jedno z těchto slov není číslovkou.\tpreloaded/ententen21_tt31\t(1:[tag!="CD"] 2:[tag!="CD"] within <s/>) & 1.lemma = 2.lemma\n'
On line 252
1:[] 2:[] & 1.lemma = 2.lemma & 1.tag != "CD.*" & 2.tag != "CD.*" within <s/>
(1:[] 2:[] & 1.lemma = 2.lemma & 1.tag != "CD.*" & 2.tag != "CD.*") within <s/>
1:[] 2:[] within <s/> & 1.lemma = 2.lemma & 1.tag != "CD.*" & 2.tag != "CD.*"
((1:[] 2:[]) within <s/>) & 1.lemma = 2.lemma & 1.tag != "CD.*" & 2.tag != "CD.*"
'Potřebuji nalézt sekvenci čtyř slov, ve které první a druhé slovo mají stejný tag a první a poslední mají stejné lemma.\tpreloaded/ententen21_tt31\t1:[] 2:[] [] 3:[] & 1.tag = 2.tag & 1.lemma = 3.lemma\n'
On line 253
1:[] 2:[] 3:[] 4:[] & 1.tag = 2.tag & 1.lemma = 4.lemma
1:[] 2:[] 3:[] 4:[] & 1.pos = 2.pos & 1.lemma = 4.lemma
1:[] 2:[] 3:[] 4:[] & 1.tag = 2.tag & 1.lemma = 4.lemma
1:[] 2:[] 3:[] 4:[] & (1.pos = 2.pos) & (1.lemma = 4.lemma)
'Chtěl bych nalézt případy, kdy ve věte sloveso následované po podstatném jméně má stejné lemma, jako předcházející podstatné jméno.\tpreloaded/ententen21_tt31\t(1:[tag="N.*"]2:[tag="V.*"] within <s/>) & 1.lemma = 2.lemma\n'
On line 254
1:[] 2:[] & 1.tag="N.*" & 2.tag="V.*" & 1.lemma=2.lemma
1:[tag="N.*"] 2:[tag="V.*"] & 1.lemma=2.lemma
1:[] 2:[] & 1.lempos_lc=".*-n" & 2.lempos_lc=".*-v" & 1.lemma=2.lemma
1:[] 2:[] & 1.pos="N.*" & 2.pos="V.*" & 1.lemma=2.lemma
'Zajímalo by mě, zda existují dvě po sobě jdoucí přídavná jména, následovaná podstatným jménem, kdy frekvence prvního přídavného jména je vyšší něž 100000 a frekvence druhého je menší než 5000.\tpreloaded/ententen21_tt31\t1:[tag="J.*"]2:[tag="J.*"][tag="N.*"] & f(1.word) > 100000 & f(2.word) < 5000\n'
On line 255
1:[tag="J.*"] 2:[tag="J.*"] 3:[tag="N.*"] & f(1.word)>100000 & f(2.word)<5000
'Existují dvě po sobě jdoucí slova, která mají stejné lemma, ale jejich záspis, nezávisle na velikosti písmen, se liší?\tpreloaded/ententen21_tt31\t1:[]2:[] & 1.lemma = 2.lemma & 1.lc != 2.lc\n'
On line 256
1:[] 2:[] & 1.lemma = 2.lemma & 1.lc != 2.lc
1:[] 2:[] & (1.lemma = 2.lemma) & (1.lc != 2.lc)
1:[] 2:[] & 1.lemma = 2.lemma & 1.word != 2.word
1:[] 2:[] & 1.lc = 2.lc & 1.word != 2.word
'Dají se najít dvě po sobě jdoucí slova, kde první nebo druhé má frekvenci vyšší než 2000000000?\tpreloaded/ententen21_tt31\t1:[]2:[] & f(1.word) > 2000000000 | f(2.word) > 2000000000\n'
On line 257
1:[] 2:[] & ( f(1.word) > 2000000000 | f(2.word) > 2000000000 )
'Chci slovo raketa z domény nasa.gov.\tpreloaded/ententen21_tt31\t[word="rocket"] within <doc urldomain="nasa\\.gov" />\n'
On line 258
<doc urldomain="nasa.gov">[word="raketa"]
'Zajímali by mě všechna slova univerzita v doménách končících na .edu .\tpreloaded/ententen21_tt31\t[lemma="university"] within <doc tld="edu"/>\n'
On line 259
<doc tld="edu">[lemma="university"]
'Výskyty slova agrese v dokumentech s tématem hry.\tpreloaded/ententen21_tt31\t[lemma="aggression"] within <doc topic="games"/>\n'
On line 260
[word="agrese"] within <doc topic="hry"/>
'Výskyty slova agrese v dokumentech s tématem hry nebo vzdělání.\tpreloaded/ententen21_tt31\t[lemma="aggression"] within <doc topic="games|education"/>\n'
On line 261
(<doc topic="hry">[word="agrese"]</doc>) | (<doc topic="vzdělání">[word="agrese"]</doc>)
'Zajímaly by mě výskyty reklam na blogech.\tpreloaded/ententen21_tt31\t[lemma="advertisement|ad"] within <doc genre="blog"/>\n'
On line 262
<doc genre="blog"> ([lemma="advert.*"]|[lemma="ad"]|[lemma="sponsor.*"]|[lemma="promo.*"])
'Zajímají mě výskyty fráze "Barack Obama" ve všech dokumentech, kde titulek obsahuje slovo "skandál".\tpreloaded/ententen21_tt31\t[word="Barack"][word="Obama"] within <doc title=".*scandal.*" />\n'
On line 263
<doc title=".*skandál.*">[word="Barack"][word="Obama"]
'Potřebuji výskyty slova COVID po roce 2019.\tpreloaded/trends_en\t[word="COVID"] within <doc year="20[2-9]." />\n'
On line 264
1:[lc="covid"] & 1.doc.year >= 2020
<doc year="202[0-9]">[lc="covid"]
'Potřebuji výskyty slova podzemí ve městě Brně.\tpreloaded/trends_en\t[lemma="underground"] within <doc city="Brno"/>\n'
On line 265
<doc city="Brno">[word="podzemí"]</doc>
'Zajímají mě všechny novinové články, ve kterých se vyskytuje sloveso "hack".\tpreloaded/trends_en\t[lemma="hack" & tag="V.*"] within <doc genre="news"/>\n'
On line 266
<doc genre="news"/> containing [lemma="hack" & tag="V.*"]
'Výskyty slova leprikon v dokumentech pocházejících z Irska.\tpreloaded/trends_en\t[lemma="leprechaun"] within <doc country="Ireland" />\n'
On line 267
<doc country="Ireland">[word="leprikon"]
'Zajímali by mě výskyty slova zmrzlina v dokumentech, které byly publikovány v červnu.\tpreloaded/trends_en\t[word="ice"][word="cream"] within <doc month=".+-06"/>\n'
On line 268
[word="zmrzlina"] within <doc month="June"/>
'Najdi věty v přímé řeči (začínající uvozovkou).\tpreloaded/ententen21_tt31\t<s> [word="\\""]\n'
On line 269
<s/> containing ([word="\""] []*)
'Najdi věty, které obsahují číslo větší než 100.\tpreloaded/ententen21_tt31\t<s/> containing [tag="CD" & word>="101"]\n'
On line 270
[{'role': 'system', 'content': [{'type': 'text', 'text': 'Definition of Corpus Query Language (CQL)\n    The CQL is a query language used in Sketch Engine for searching grammatical and lexical patterns. CQL sets criteria for positions and tokens, such as tag, word, lemma, lempos, etc.\n    Basic syntax is [attribute="value"], for example:\n    To find the lemma teapot, use\n    CQL:\n    ```cql\n    [lemma="teapot"]\n    ```\n    Each token must be inside its own pair of square brackets. To search for the phrase refill the teapot, use\n    CQL:\n    ```cql\n    [lemma="refill"][lemma="the"][lemma="teapot"]\n    ```\n    More examples:\n    find examples of went -> CQL:\n    ```cql\n    [word="went"]\n    ```\n    find examples of all forms of go -> CQL:\n    ```cql\n    [lemma="go"]\n    ```\n    find examples of all words tagged with the tag NP -> CQL:\n    ```cql\n    [tag="NP"]\n    ```\n\n    Regular expressions can be used with values in CQL. A complete set of Regular expressions is supported, and complex criteria can be used, for example:\n    words starting with confus- -> CQL:\n    ```cql\n    [lemma="confus.*"]\n    ```\n    words ending with -ious -> CQL:\n    ```cql\n    [lemma=".*ious"]\n    ```\n    three-letter words starting b- and ending -g -> CQL:\n    ```cql\n    [lemma="b.g"]\n    ```\n    Be aware that when searching for any of the characters [][.*+{}?()|\\\\"$^] literally, they must be escaped using a backslash in any context where you may used regular expressions.\n\n    Square brackets [ ] stand for "any token". Curly brackets { } are used for repetition of the preceding token, for example:\n    find examples of ‘refill’ and ‘kettle’ with one word in between -> CQL:\n    ```cql\n    [lemma="refill"] [ ] [lemma="kettle"]\n    ```\n    examples of ‘have’ and ‘opinion’ with 2 to 4 words in between -> CQL:\n    ```cql\n    [lemma="have"] [ ]{2,4}[lemma="opinion"]\n    ```\n    find examples of "drink" and "water" with exactly two adjectives between them -> CQL:\n    ```cql\n    [lemma="drink"] [tag="J.*"]{2}[lemma="water"]\n    ```\n\n    A token can be made optional by placing a question mark ? after the square bracket. For example:\n    Find examples of ‘drive my car’ or ‘drive my own car’ -> CQL:\n    ```cql\n    [lemma="drive"] [lc="my"] [lc="own"]? [lemma="car"]\n    ```\n    alternative solution without using ? -> CQL:\n    ```cql\n    [lemma="drive"][lc="my"][lc="own"]{0,1} [lemma="car"]\n    ```\n\n    These comparison operators are supported:\n    equal =\n    less than or equal to <=\n    more than or equal to >=\n    not equal !=\n    not less than or equal to !<=\n    not more than or equal to !>=\n    equal (no regex) ==\n    not equal (no regex) !==\n    The alphabetical parts of the value are compared lexicographically (‘in the dictionary order’) and numerical parts numerically. This is useful with structure attributes, where >="AB2010CD" will include values such as "BB0000CD", "AB2011CD" or "AB2010CE". Example:\n    all one-letter words -> CQL:\n    ```cql\n    [word="."]\n    ```\n    all full stops -> CQL:\n    ```cql\n    [word=="."]\n    ```\n\n    One token can have more conditions. They must all appear inside the same pair of square brackets, and Boolean operators must be used between them.\n    & (ampersand) = AND\n    | (pipe) = OR\n    ! (exclamation mark) = NOT\n    For example:\n    Find all forms of the word ‘test’ which is a noun -> CQL:\n    ```cql\n    [ lemma="test" & tag="N.*" ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & tag!="V.*"]\n    ```\n    finds the word round tagged as a noun or verb -> CQL:\n    ```cql\n    [ word="round" & ( tag="N.*" | tag="V.*" ) ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & !tag="V.*"]\n    ```\n\n    | (pipe) = OR - means one token or another token, i.e., the token to the right or left of the pipe.\n    This use of the pipe (|) should only be limited to cases with no other solution because it consumes the search time. In most cases, it can be replaced by a pipe used inside the token, which is faster. See examples below.\n    "big dog" or "wolf" -> CQL:\n    ```cql\n    ([lemma="big"][lemma="dog"]) | [lemma="wolf"]\n    ```\n\n    Structures refer to sentences, paragraphs, documents, or any other parts or sections into which a corpus might be divided. Another way of saying this is that certain parts of a corpus can be labelled, e.g., direct speech might be labelled using structures to make it possible to limit the search to only direct speech. Structures may or may not have values. Values are used to categorize instances of the same structure.\n    Structures can be referred to in three ways:\n    The beginning: <s> <p> <doc> etc.\n    The end: </s> </p> </doc> etc.\n    The whole structure: <s/> <p/> <doc/> etc.\n    For example:\n    Find all documents written in informal style that start with the word Rebecca -> CQL:\n    ```cql\n    <doc style="informal">[lemma="Rebecca"]\n    ```\n    find all documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    Written documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011" & type="written"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    find all verbs written in informal style -> CQL:\n    ```cql\n    [tag="V.*"]  within <doc style="informal" />\n    ```\n\n    The "containing" and "within" CQL operators are used to restrict the search only to a certain structure, e.g., to search inside:\n    Corpus structure, e.g., sentence, paragraph, document, etc.\n    Grammatical or lexical structure, e.g., noun phrase.\n\n    Use within to ensure the search result appears within the structure you want, in this case, within the same sentence, paragraph, document, or any other structure found in the corpus:\n    CQL:\n    ```cql\n    [word="dog"] []{0,5} [word="runs"] within < s/>\n    ```\n    The structure after "within" can be another CQL code defining a grammatical or lexical structure:\n    CQL:\n    ```cql\n    [tag="N.*"] within [tag="VB.*"] []{0,5} [tag="VB.*"]\n    ```\n    Multiple within operators can be nested if necessary:\n    CQL:\n    ```cql\n    [tag="N.*"] within ([tag="VB.*"] []{0,5} [tag="VB.*"] within < s/>)\n    ```\n    Use within to search a parallel corpus using this syntax:\n    within :\n    For example, with the English Europarl open, you can use this CQL to query the German Europarl. It will find all segments where the English corpus contains car and the aligned German segment contains Auto. In most cases, these will be segments where car was translated as Auto:\n    CQL:\n    ```cql\n    [word="car"] within europarl5_de: [word="Auto"]\n    ```\n\n    Use containing to find the whole structure and to display the whole structure as the result (KWIC).\n    This will find all paragraphs containing an acronym, i.e. a word consisting of 3 or more upper-case characters:\n    CQL:\n    ```cql\n    <p/> containing [word="[A-Z]{3,}"]\n    ```\n    This query searches for noun phrases (sequences of up to 5 adjectives followed by a noun) that contain the adjective international:\n    ```cql\n    [tag="J.*"]{1,5} [tag="N.*"] containing [word="international"]\n    ```\n\n    Use ! for negation:\n    !within = not within\n    !containing = not containing\n\n    This CQL will find all nouns that appear outside the <nphr> structure, i.e., outside noun phrases. The CQL will only work in corpora where the <nphr> structure exists:\n    CQL:\n    ```cql\n    [tag="N.*"]   !within   <nphr/>\n    ```\n    This CQL will find all sentences that do not contain any word starting with a capital letter:\n    CQL:\n    ```cql\n    <s/>   !containing   [word="[A-Z][A-Za-z]*"]\n    ```\n\n    Simultaneously searching the left and right context is only possible with meet and union operators. This is useful when a user wants to search for a token that is around or in the area of some other token.\n    Use meet to set the left and right context. This will find all nouns that have the verb to be 3 tokens to the left or 3 tokens to the right:\n    CQL:\n    ```cql\n    (meet [tag = "N.*"] [tag = "VB.*"] -3 3)\n    ```\n    Use the operator union to collect the results of two meet queries and display them in one concordance.\n    This CQL will, find all nouns with the verb to be at a distance of 3 tokens to the left or right, then find all adjectives with the verb to be at a distance of 2 tokens to the left or right, combine the nouns from the first query and adjectives from the second query and display them together in one concordance, the nouns and adjectives will be highlighted in the centre as KWIC:\n    CQL:\n    ```cql\n    (union (meet [tag="N.*"] [tag="VB.*"] -3 3) (meet [tag="A.*"] [tag="VB.*"] -2 2))\n    ```\n    This combines instances of nouns preceded by competent with adjectives followed by competence:\n    CQL:\n    ```cql\n    (union(meet [tag="N.*"] [lemma="competent"] -2 -1)(meet [tag="J.*"] [lemma="competence"]  1 2))\n    ```\n    Note that each meet and union has to be inside its own pair of brackets. Operators meet, and a union cannot be used with operators within and containing.\n\n    CQL also supports word sketch. Word sketches provide collocations for a word. The syntax is as follows:\n    CQL:\n    ```cql\n    [ws(headword, relation, collocation)]\n    ```\n    The relation is the name of the relation. You can often guess the name by using a regular expression like this:\n    CQL:\n    ```cql\n    [ws(headword, ".*subject.*", collocation)]\n    ```\n    For the exact name of the relation, the "%w" must be exchanged for \\"%w\\" as the quotes need to be backslashed in CQL. For example, the Word Sketch relation modifiers of "book" can be written as a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", "modifiers of \\"%w\\"", ".*")]\n    ```\n    Remember that Word Sketches are generated from lempos, so using a hyphen and the shortened PoS tag is necessary. For example, to generate a concordance with test (as a noun) being the object of conduct (as a verb), use this:\n    CQL:\n    ```cql\n    [ws("test-n",".*object.*","conduct-v")]\n    ```\n    In the resulting concordance, the headword is taken for a KWIC, and the collocations are used as a filter. It is possible to specify the headword by using the regular expression AND inside the square brackets. For example, to search for all relations of lempos "book-n" where the word appears in the plural form, you can use a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", ".*", ".*") & tag="NNS"]\n    ```\n    The prepositional phrases can be searched by the following syntax:\n    CQL:\n    ```cql\n    [ws("headword", "\\.\\.\\. [^ /]+ \\"%w\\"", ".*") | ws("headword", "\\"%w\\" [^ /]+ \\.\\.\\.", ".*")]\n    ```\n    In case only specific prepositions should be displayed, it is possible to insert them instead of [^ /]. This example will find concordance lines with the headword ‘test’ as a noun and prepositions of, in, or at:\n    CQL:\n    ```cql\n    [ws("test-n", "\\.\\.\\. (of|in|at) \\"%w\\"", ".*") | ws("test-n", "\\"%w\\" (of|in|at) \\.\\.\\.", ".*")]\n    ```\n    The Word Sketch CQL can be combined with other CQL markers. To generate a concordance where the headword test is modified by blood and followed or preceded by the lemma be, use this:\n    CQL:\n    ```cql\n    (meet [ws("test-n",".*modifiers of.*","blood-n")] [lemma="be"] -1 1)\n    ```\n\n    Thesaurus is also supported in CQL. Use the tilde ~ to generate a thesaurus (words with similar context, synonyms, antonyms) for the word and include the top N thesaurus items into the query. For example, to find the verb chop followed by vegetables, use this (or replace carrot with any other vegetable):\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~"carrot-n"\n    ```\n    To set the number of thesaurus items manually, use:\n    CQL:\n    ```cql\n    ~15"carrot-n"\n    ```\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~15"carrot-n"\n    ```\n    Thesaurus may be used with meet keyword, for example, to find all metals around the lemma corrosion:\n    CQL:\n    ```cql\n    (meet ~"metal-n" [lemma="corrosion"] -5 5)\n    ```\n\n    It is possible to add aditional constraints called global conditions.\n    You may use \'<number>:\' to specify a tag and then after whole CQL put & and write a global constraint. Only numbers may be used. For example:\n\n    Repetition of the same token:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word\n    ```\n    Repetition of the same token but different tag:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word & 1.tag != 2.tag\n    ```\n    Token with frequency higher than 2000\n    CQL:\n    ```cql\n    1:[] & f(1.word)>2000\n    ```\n\nYou are an expert assistant for Sketch Engine\'s Corpus Query Language (CQL).\nYour job is to read the conversation and translate the user\'s *latest* request into a single CQL query.\n\nImportant CQL reminders:\n- A query is a sequence of tokens, each inside square brackets: [ ... ].\n- Use attributes like word, lemma, tag, lc, lempos, structure attributes, etc.\n- Use regular expressions only when necessary.\n- Prefer lemma="..." when the user asks for \'all forms\' of a word.\n- Follow corpus-specific tags, annotations, structures and grammatical relations.\n\nCorpus description for corpus \'preloaded/ententen21_tt31\':\nCorpus language: English  \n\nCore token structures (each token has a separate record):  \n- word : the surface form  \n- tag : TreeTagger POS tag (see tag table below)  \n- lempos : lemma plus POS suffix (e.g. “run‑v”)  \n- pos : same as tag (kept for compatibility)  \n- lemma : lemmatized form  \n- lempos_lc : lempos in lowercase  \n- lemma_lc : lemma in lowercase  \n- lc : word in lowercase  \n\nDocument‑level structures (one per text):  \n- doc – attributes: url, title, wiki_categories, urldomain, website, crawl_date, modified_date, tld, wiki_translations, modified_month, modified_year, topic, tld_expl, domain_distance, genre, src, crawl_year  \n- p – attribute: heading (section heading)  \n- s – sentence identifier  \n- g – generic grouping (no attributes)  \n\nAnnotations (regular‑expression shortcuts for the tag field):  \n- adjective : “J.*”  \n- adverb : “RB.?”  \n- conjunction : “CC”  \n- determiner : “DT”  \n- noun : “N.*”  \n- numeral : “CD”  \n- particle : “RP”  \n- preposition : “IN”  \n- pronoun : “PP.?”  \n- verb : “V.*”  \n\nLempos suffixes (used in the lempos and lempos_lc fields):  \n‑j adjective\u2003‑a adverb\u2003‑c conjunction\u2003‑n noun\u2003‑m numeral\u2003‑i preposition\u2003‑d pronoun\u2003‑v verb  \n\n---  \n\nTreeTagger POS tagset (Sketch Engine modifications)  \n\nTag\u2003Description\u2003Example  \nCC\u2003coordinating conjunction\u2003and  \nCD\u2003cardinal number\u20031, one  \nCDZ\u2003possessive numeral\u2003one’s  \nDT\u2003determiner\u2003the  \nEX\u2003existential “there”\u2003there  \nFW\u2003foreign word\u2003d’hoevre  \nIN\u2003preposition or subordinating conjunction\u2003in, of, like  \nIN/that\u2003that as subordinator\u2003that  \nJJ\u2003adjective\u2003green  \nJJR\u2003adjective comparative\u2003greener  \nJJS\u2003adjective superlative\u2003greenest  \nLS\u2003list marker\u20031)  \nMD\u2003modal verb\u2003could, will  \nNN\u2003noun singular or mass\u2003table  \nNNS\u2003noun plural\u2003tables  \nNNSZ\u2003possessive noun plural\u2003people’s  \nNNZ\u2003possessive noun singular\u2003year’s  \nNP\u2003proper noun singular\u2003John  \nNPS\u2003proper noun plural\u2003Vikings  \nNPSZ\u2003possessive proper noun plural\u2003Boys’  \nNPZ\u2003possessive proper noun singular\u2003Britain’s  \nPDT\u2003predeterminer\u2003both the boys  \nPP\u2003personal pronoun\u2003I, he, it  \nPPZ\u2003possessive pronoun\u2003my, his  \nRB\u2003adverb\u2003however, usually  \nRBR\u2003adverb comparative\u2003better  \nRBS\u2003adverb superlative\u2003best  \nRP\u2003particle\u2003up (in “give up”)  \nSENT\u2003sentence‑final punctuation\u2003. ! ?  \nSYM\u2003other symbols\u2003/ = *  \nTO\u2003infinitive marker\u2003to (only when infinitival)  \nUH\u2003interjection\u2003uhhuhhuhh  \nVB\u2003verb “be”, base\u2003be  \nVBD\u2003verb “be”, past\u2003was, were  \nVBG\u2003verb “be”, gerund\u2003being  \nVBN\u2003verb “be”, past participle\u2003been  \nVBP\u2003verb “be”, present non‑3rd\u2003am, are  \nVBZ\u2003verb “be”, 3rd‑person present\u2003is  \nVH\u2003verb “have”, base\u2003have  \nVHD\u2003verb “have”, past\u2003had  \nVHG\u2003verb “have”, gerund\u2003having  \nVHN\u2003verb “have”, past participle\u2003had  \nVHP\u2003verb “have”, present non‑3rd\u2003have  \nVHZ\u2003verb “have”, 3rd‑person present\u2003has  \nVV\u2003other verbs, base\u2003take  \nVVD\u2003other verbs, past\u2003took  \nVVG\u2003other verbs, gerund\u2003taking  \nVVN\u2003other verbs, past participle\u2003taken  \nVVP\u2003other verbs, present non‑3rd\u2003take  \nVVZ\u2003other verbs, 3rd‑person present\u2003takes  \nWDT\u2003wh‑determiner\u2003which  \nWP\u2003wh‑pronoun\u2003who, what  \nWPZ\u2003possessive wh‑pronoun\u2003whose  \nWRB\u2003wh‑adverb\u2003where, when  \nZ\u2003possessive ending\u2003’s  \n\nKey differences from the Penn Treebank:  \n- “be” uses VB/VBD/VBG/VBN/VBP/VBZ, “have” uses VH/VHD/VHG/VHN/VHP/VHZ, all other verbs use VV series.  \n- Proper nouns are NP/NPS (instead of NNP/NNPS).  \n- SENT marks sentence‑final punctuation.  \n- Token “to” is tagged IN when a preposition, TO only when infinitival.  \n- Indefinite articles “a”/“an” are both lemmatized as “a”.  \n\nWord‑sketch (grammatical relation) patterns (use “%w” as the target word placeholder). Typical relation names that can be queried in CQL include:  \n\n%w is a …\u2003%w’s …\u2003… is a %w\u2003adjective predicates of %w\u2003adjectives after %w\u2003adjectives modified by %w\u2003adverbs modified by %w\u2003as reflexive\u2003complements of %w\u2003in passive\u2003infinitive objects of %w\u2003it’s %w to …\u2003modifiers of %w\u2003nouns modified by %w\u2003objects of %w\u2003objects of %w across/along/apart/around/aside/away/down/in/off/on/open/out/over/through/unto/up/upon/whole\u2003particles after %w (with object)\u2003possessors of %w\u2003prepositional phrases\u2003pronominal objects/possessors/subjects of %w\u2003subjects of %w\u2003subjects of “be %w”\u2003verbs before %w\u2003verbs complemented by %w\u2003verbs modified by %w\u2003verbs with %w as object\u2003verbs with %w as subject\u2003verbs with particle “across/along/…/upon” and %w as object\u2003wh‑words following %w  \n\nThese relation names correspond to the default word‑sketch grammar; they can be used in CQL with the syntax `[word="target"] [relation="relation_name"]` or via the built‑in shortcuts `[%w]` in the Sketch Engine UI.  \n\nDocument‑level filtering can be done on any doc attribute, e.g. `[doc.genre="news"]`, `[doc.crawl_year="2023"]`, `[doc.tld="com"]`.  \n\nAll structures and attributes are case‑sensitive; use straight double quotes in CQL expressions.\n\nOutput format requirements (very important):\n1. Respond with EXACTLY one fenced code block.\n2. The fence must be in this format:\n```cql\n[your CQL query here]\n```\n3. Do output any text before the code block. Use this for reasoning.\n4. Do explain the query, comment on it, or paraphrase the user. Before the code block.\n5. Do not ask for clarification. Respond directly.\n'}]}, {'role': 'user', 'content': [{'type': 'text', 'text': 'Najdi věty, které obsahují číslo větší než 100.'}]}]
{"detail":"Use of API key is not enabled in the environment."}
[{'role': 'system', 'content': [{'type': 'text', 'text': 'Definition of Corpus Query Language (CQL)\n    The CQL is a query language used in Sketch Engine for searching grammatical and lexical patterns. CQL sets criteria for positions and tokens, such as tag, word, lemma, lempos, etc.\n    Basic syntax is [attribute="value"], for example:\n    To find the lemma teapot, use\n    CQL:\n    ```cql\n    [lemma="teapot"]\n    ```\n    Each token must be inside its own pair of square brackets. To search for the phrase refill the teapot, use\n    CQL:\n    ```cql\n    [lemma="refill"][lemma="the"][lemma="teapot"]\n    ```\n    More examples:\n    find examples of went -> CQL:\n    ```cql\n    [word="went"]\n    ```\n    find examples of all forms of go -> CQL:\n    ```cql\n    [lemma="go"]\n    ```\n    find examples of all words tagged with the tag NP -> CQL:\n    ```cql\n    [tag="NP"]\n    ```\n\n    Regular expressions can be used with values in CQL. A complete set of Regular expressions is supported, and complex criteria can be used, for example:\n    words starting with confus- -> CQL:\n    ```cql\n    [lemma="confus.*"]\n    ```\n    words ending with -ious -> CQL:\n    ```cql\n    [lemma=".*ious"]\n    ```\n    three-letter words starting b- and ending -g -> CQL:\n    ```cql\n    [lemma="b.g"]\n    ```\n    Be aware that when searching for any of the characters [][.*+{}?()|\\\\"$^] literally, they must be escaped using a backslash in any context where you may used regular expressions.\n\n    Square brackets [ ] stand for "any token". Curly brackets { } are used for repetition of the preceding token, for example:\n    find examples of ‘refill’ and ‘kettle’ with one word in between -> CQL:\n    ```cql\n    [lemma="refill"] [ ] [lemma="kettle"]\n    ```\n    examples of ‘have’ and ‘opinion’ with 2 to 4 words in between -> CQL:\n    ```cql\n    [lemma="have"] [ ]{2,4}[lemma="opinion"]\n    ```\n    find examples of "drink" and "water" with exactly two adjectives between them -> CQL:\n    ```cql\n    [lemma="drink"] [tag="J.*"]{2}[lemma="water"]\n    ```\n\n    A token can be made optional by placing a question mark ? after the square bracket. For example:\n    Find examples of ‘drive my car’ or ‘drive my own car’ -> CQL:\n    ```cql\n    [lemma="drive"] [lc="my"] [lc="own"]? [lemma="car"]\n    ```\n    alternative solution without using ? -> CQL:\n    ```cql\n    [lemma="drive"][lc="my"][lc="own"]{0,1} [lemma="car"]\n    ```\n\n    These comparison operators are supported:\n    equal =\n    less than or equal to <=\n    more than or equal to >=\n    not equal !=\n    not less than or equal to !<=\n    not more than or equal to !>=\n    equal (no regex) ==\n    not equal (no regex) !==\n    The alphabetical parts of the value are compared lexicographically (‘in the dictionary order’) and numerical parts numerically. This is useful with structure attributes, where >="AB2010CD" will include values such as "BB0000CD", "AB2011CD" or "AB2010CE". Example:\n    all one-letter words -> CQL:\n    ```cql\n    [word="."]\n    ```\n    all full stops -> CQL:\n    ```cql\n    [word=="."]\n    ```\n\n    One token can have more conditions. They must all appear inside the same pair of square brackets, and Boolean operators must be used between them.\n    & (ampersand) = AND\n    | (pipe) = OR\n    ! (exclamation mark) = NOT\n    For example:\n    Find all forms of the word ‘test’ which is a noun -> CQL:\n    ```cql\n    [ lemma="test" & tag="N.*" ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & tag!="V.*"]\n    ```\n    finds the word round tagged as a noun or verb -> CQL:\n    ```cql\n    [ word="round" & ( tag="N.*" | tag="V.*" ) ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & !tag="V.*"]\n    ```\n\n    | (pipe) = OR - means one token or another token, i.e., the token to the right or left of the pipe.\n    This use of the pipe (|) should only be limited to cases with no other solution because it consumes the search time. In most cases, it can be replaced by a pipe used inside the token, which is faster. See examples below.\n    "big dog" or "wolf" -> CQL:\n    ```cql\n    ([lemma="big"][lemma="dog"]) | [lemma="wolf"]\n    ```\n\n    Structures refer to sentences, paragraphs, documents, or any other parts or sections into which a corpus might be divided. Another way of saying this is that certain parts of a corpus can be labelled, e.g., direct speech might be labelled using structures to make it possible to limit the search to only direct speech. Structures may or may not have values. Values are used to categorize instances of the same structure.\n    Structures can be referred to in three ways:\n    The beginning: <s> <p> <doc> etc.\n    The end: </s> </p> </doc> etc.\n    The whole structure: <s/> <p/> <doc/> etc.\n    For example:\n    Find all documents written in informal style that start with the word Rebecca -> CQL:\n    ```cql\n    <doc style="informal">[lemma="Rebecca"]\n    ```\n    find all documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    Written documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011" & type="written"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    find all verbs written in informal style -> CQL:\n    ```cql\n    [tag="V.*"]  within <doc style="informal" />\n    ```\n\n    The "containing" and "within" CQL operators are used to restrict the search only to a certain structure, e.g., to search inside:\n    Corpus structure, e.g., sentence, paragraph, document, etc.\n    Grammatical or lexical structure, e.g., noun phrase.\n\n    Use within to ensure the search result appears within the structure you want, in this case, within the same sentence, paragraph, document, or any other structure found in the corpus:\n    CQL:\n    ```cql\n    [word="dog"] []{0,5} [word="runs"] within < s/>\n    ```\n    The structure after "within" can be another CQL code defining a grammatical or lexical structure:\n    CQL:\n    ```cql\n    [tag="N.*"] within [tag="VB.*"] []{0,5} [tag="VB.*"]\n    ```\n    Multiple within operators can be nested if necessary:\n    CQL:\n    ```cql\n    [tag="N.*"] within ([tag="VB.*"] []{0,5} [tag="VB.*"] within < s/>)\n    ```\n    Use within to search a parallel corpus using this syntax:\n    within :\n    For example, with the English Europarl open, you can use this CQL to query the German Europarl. It will find all segments where the English corpus contains car and the aligned German segment contains Auto. In most cases, these will be segments where car was translated as Auto:\n    CQL:\n    ```cql\n    [word="car"] within europarl5_de: [word="Auto"]\n    ```\n\n    Use containing to find the whole structure and to display the whole structure as the result (KWIC).\n    This will find all paragraphs containing an acronym, i.e. a word consisting of 3 or more upper-case characters:\n    CQL:\n    ```cql\n    <p/> containing [word="[A-Z]{3,}"]\n    ```\n    This query searches for noun phrases (sequences of up to 5 adjectives followed by a noun) that contain the adjective international:\n    ```cql\n    [tag="J.*"]{1,5} [tag="N.*"] containing [word="international"]\n    ```\n\n    Use ! for negation:\n    !within = not within\n    !containing = not containing\n\n    This CQL will find all nouns that appear outside the <nphr> structure, i.e., outside noun phrases. The CQL will only work in corpora where the <nphr> structure exists:\n    CQL:\n    ```cql\n    [tag="N.*"]   !within   <nphr/>\n    ```\n    This CQL will find all sentences that do not contain any word starting with a capital letter:\n    CQL:\n    ```cql\n    <s/>   !containing   [word="[A-Z][A-Za-z]*"]\n    ```\n\n    Simultaneously searching the left and right context is only possible with meet and union operators. This is useful when a user wants to search for a token that is around or in the area of some other token.\n    Use meet to set the left and right context. This will find all nouns that have the verb to be 3 tokens to the left or 3 tokens to the right:\n    CQL:\n    ```cql\n    (meet [tag = "N.*"] [tag = "VB.*"] -3 3)\n    ```\n    Use the operator union to collect the results of two meet queries and display them in one concordance.\n    This CQL will, find all nouns with the verb to be at a distance of 3 tokens to the left or right, then find all adjectives with the verb to be at a distance of 2 tokens to the left or right, combine the nouns from the first query and adjectives from the second query and display them together in one concordance, the nouns and adjectives will be highlighted in the centre as KWIC:\n    CQL:\n    ```cql\n    (union (meet [tag="N.*"] [tag="VB.*"] -3 3) (meet [tag="A.*"] [tag="VB.*"] -2 2))\n    ```\n    This combines instances of nouns preceded by competent with adjectives followed by competence:\n    CQL:\n    ```cql\n    (union(meet [tag="N.*"] [lemma="competent"] -2 -1)(meet [tag="J.*"] [lemma="competence"]  1 2))\n    ```\n    Note that each meet and union has to be inside its own pair of brackets. Operators meet, and a union cannot be used with operators within and containing.\n\n    CQL also supports word sketch. Word sketches provide collocations for a word. The syntax is as follows:\n    CQL:\n    ```cql\n    [ws(headword, relation, collocation)]\n    ```\n    The relation is the name of the relation. You can often guess the name by using a regular expression like this:\n    CQL:\n    ```cql\n    [ws(headword, ".*subject.*", collocation)]\n    ```\n    For the exact name of the relation, the "%w" must be exchanged for \\"%w\\" as the quotes need to be backslashed in CQL. For example, the Word Sketch relation modifiers of "book" can be written as a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", "modifiers of \\"%w\\"", ".*")]\n    ```\n    Remember that Word Sketches are generated from lempos, so using a hyphen and the shortened PoS tag is necessary. For example, to generate a concordance with test (as a noun) being the object of conduct (as a verb), use this:\n    CQL:\n    ```cql\n    [ws("test-n",".*object.*","conduct-v")]\n    ```\n    In the resulting concordance, the headword is taken for a KWIC, and the collocations are used as a filter. It is possible to specify the headword by using the regular expression AND inside the square brackets. For example, to search for all relations of lempos "book-n" where the word appears in the plural form, you can use a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", ".*", ".*") & tag="NNS"]\n    ```\n    The prepositional phrases can be searched by the following syntax:\n    CQL:\n    ```cql\n    [ws("headword", "\\.\\.\\. [^ /]+ \\"%w\\"", ".*") | ws("headword", "\\"%w\\" [^ /]+ \\.\\.\\.", ".*")]\n    ```\n    In case only specific prepositions should be displayed, it is possible to insert them instead of [^ /]. This example will find concordance lines with the headword ‘test’ as a noun and prepositions of, in, or at:\n    CQL:\n    ```cql\n    [ws("test-n", "\\.\\.\\. (of|in|at) \\"%w\\"", ".*") | ws("test-n", "\\"%w\\" (of|in|at) \\.\\.\\.", ".*")]\n    ```\n    The Word Sketch CQL can be combined with other CQL markers. To generate a concordance where the headword test is modified by blood and followed or preceded by the lemma be, use this:\n    CQL:\n    ```cql\n    (meet [ws("test-n",".*modifiers of.*","blood-n")] [lemma="be"] -1 1)\n    ```\n\n    Thesaurus is also supported in CQL. Use the tilde ~ to generate a thesaurus (words with similar context, synonyms, antonyms) for the word and include the top N thesaurus items into the query. For example, to find the verb chop followed by vegetables, use this (or replace carrot with any other vegetable):\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~"carrot-n"\n    ```\n    To set the number of thesaurus items manually, use:\n    CQL:\n    ```cql\n    ~15"carrot-n"\n    ```\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~15"carrot-n"\n    ```\n    Thesaurus may be used with meet keyword, for example, to find all metals around the lemma corrosion:\n    CQL:\n    ```cql\n    (meet ~"metal-n" [lemma="corrosion"] -5 5)\n    ```\n\n    It is possible to add aditional constraints called global conditions.\n    You may use \'<number>:\' to specify a tag and then after whole CQL put & and write a global constraint. Only numbers may be used. For example:\n\n    Repetition of the same token:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word\n    ```\n    Repetition of the same token but different tag:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word & 1.tag != 2.tag\n    ```\n    Token with frequency higher than 2000\n    CQL:\n    ```cql\n    1:[] & f(1.word)>2000\n    ```\n\nYou are an expert assistant for Sketch Engine\'s Corpus Query Language (CQL).\nYour job is to read the conversation and translate the user\'s *latest* request into a single CQL query.\n\nImportant CQL reminders:\n- A query is a sequence of tokens, each inside square brackets: [ ... ].\n- Use attributes like word, lemma, tag, lc, lempos, structure attributes, etc.\n- Use regular expressions only when necessary.\n- Prefer lemma="..." when the user asks for \'all forms\' of a word.\n- Follow corpus-specific tags, annotations, structures and grammatical relations.\n\nCorpus description for corpus \'preloaded/ententen21_tt31\':\nCorpus language: English  \n\nCore token structures (each token has a separate record):  \n- word : the surface form  \n- tag : TreeTagger POS tag (see tag table below)  \n- lempos : lemma plus POS suffix (e.g. “run‑v”)  \n- pos : same as tag (kept for compatibility)  \n- lemma : lemmatized form  \n- lempos_lc : lempos in lowercase  \n- lemma_lc : lemma in lowercase  \n- lc : word in lowercase  \n\nDocument‑level structures (one per text):  \n- doc – attributes: url, title, wiki_categories, urldomain, website, crawl_date, modified_date, tld, wiki_translations, modified_month, modified_year, topic, tld_expl, domain_distance, genre, src, crawl_year  \n- p – attribute: heading (section heading)  \n- s – sentence identifier  \n- g – generic grouping (no attributes)  \n\nAnnotations (regular‑expression shortcuts for the tag field):  \n- adjective : “J.*”  \n- adverb : “RB.?”  \n- conjunction : “CC”  \n- determiner : “DT”  \n- noun : “N.*”  \n- numeral : “CD”  \n- particle : “RP”  \n- preposition : “IN”  \n- pronoun : “PP.?”  \n- verb : “V.*”  \n\nLempos suffixes (used in the lempos and lempos_lc fields):  \n‑j adjective\u2003‑a adverb\u2003‑c conjunction\u2003‑n noun\u2003‑m numeral\u2003‑i preposition\u2003‑d pronoun\u2003‑v verb  \n\n---  \n\nTreeTagger POS tagset (Sketch Engine modifications)  \n\nTag\u2003Description\u2003Example  \nCC\u2003coordinating conjunction\u2003and  \nCD\u2003cardinal number\u20031, one  \nCDZ\u2003possessive numeral\u2003one’s  \nDT\u2003determiner\u2003the  \nEX\u2003existential “there”\u2003there  \nFW\u2003foreign word\u2003d’hoevre  \nIN\u2003preposition or subordinating conjunction\u2003in, of, like  \nIN/that\u2003that as subordinator\u2003that  \nJJ\u2003adjective\u2003green  \nJJR\u2003adjective comparative\u2003greener  \nJJS\u2003adjective superlative\u2003greenest  \nLS\u2003list marker\u20031)  \nMD\u2003modal verb\u2003could, will  \nNN\u2003noun singular or mass\u2003table  \nNNS\u2003noun plural\u2003tables  \nNNSZ\u2003possessive noun plural\u2003people’s  \nNNZ\u2003possessive noun singular\u2003year’s  \nNP\u2003proper noun singular\u2003John  \nNPS\u2003proper noun plural\u2003Vikings  \nNPSZ\u2003possessive proper noun plural\u2003Boys’  \nNPZ\u2003possessive proper noun singular\u2003Britain’s  \nPDT\u2003predeterminer\u2003both the boys  \nPP\u2003personal pronoun\u2003I, he, it  \nPPZ\u2003possessive pronoun\u2003my, his  \nRB\u2003adverb\u2003however, usually  \nRBR\u2003adverb comparative\u2003better  \nRBS\u2003adverb superlative\u2003best  \nRP\u2003particle\u2003up (in “give up”)  \nSENT\u2003sentence‑final punctuation\u2003. ! ?  \nSYM\u2003other symbols\u2003/ = *  \nTO\u2003infinitive marker\u2003to (only when infinitival)  \nUH\u2003interjection\u2003uhhuhhuhh  \nVB\u2003verb “be”, base\u2003be  \nVBD\u2003verb “be”, past\u2003was, were  \nVBG\u2003verb “be”, gerund\u2003being  \nVBN\u2003verb “be”, past participle\u2003been  \nVBP\u2003verb “be”, present non‑3rd\u2003am, are  \nVBZ\u2003verb “be”, 3rd‑person present\u2003is  \nVH\u2003verb “have”, base\u2003have  \nVHD\u2003verb “have”, past\u2003had  \nVHG\u2003verb “have”, gerund\u2003having  \nVHN\u2003verb “have”, past participle\u2003had  \nVHP\u2003verb “have”, present non‑3rd\u2003have  \nVHZ\u2003verb “have”, 3rd‑person present\u2003has  \nVV\u2003other verbs, base\u2003take  \nVVD\u2003other verbs, past\u2003took  \nVVG\u2003other verbs, gerund\u2003taking  \nVVN\u2003other verbs, past participle\u2003taken  \nVVP\u2003other verbs, present non‑3rd\u2003take  \nVVZ\u2003other verbs, 3rd‑person present\u2003takes  \nWDT\u2003wh‑determiner\u2003which  \nWP\u2003wh‑pronoun\u2003who, what  \nWPZ\u2003possessive wh‑pronoun\u2003whose  \nWRB\u2003wh‑adverb\u2003where, when  \nZ\u2003possessive ending\u2003’s  \n\nKey differences from the Penn Treebank:  \n- “be” uses VB/VBD/VBG/VBN/VBP/VBZ, “have” uses VH/VHD/VHG/VHN/VHP/VHZ, all other verbs use VV series.  \n- Proper nouns are NP/NPS (instead of NNP/NNPS).  \n- SENT marks sentence‑final punctuation.  \n- Token “to” is tagged IN when a preposition, TO only when infinitival.  \n- Indefinite articles “a”/“an” are both lemmatized as “a”.  \n\nWord‑sketch (grammatical relation) patterns (use “%w” as the target word placeholder). Typical relation names that can be queried in CQL include:  \n\n%w is a …\u2003%w’s …\u2003… is a %w\u2003adjective predicates of %w\u2003adjectives after %w\u2003adjectives modified by %w\u2003adverbs modified by %w\u2003as reflexive\u2003complements of %w\u2003in passive\u2003infinitive objects of %w\u2003it’s %w to …\u2003modifiers of %w\u2003nouns modified by %w\u2003objects of %w\u2003objects of %w across/along/apart/around/aside/away/down/in/off/on/open/out/over/through/unto/up/upon/whole\u2003particles after %w (with object)\u2003possessors of %w\u2003prepositional phrases\u2003pronominal objects/possessors/subjects of %w\u2003subjects of %w\u2003subjects of “be %w”\u2003verbs before %w\u2003verbs complemented by %w\u2003verbs modified by %w\u2003verbs with %w as object\u2003verbs with %w as subject\u2003verbs with particle “across/along/…/upon” and %w as object\u2003wh‑words following %w  \n\nThese relation names correspond to the default word‑sketch grammar; they can be used in CQL with the syntax `[word="target"] [relation="relation_name"]` or via the built‑in shortcuts `[%w]` in the Sketch Engine UI.  \n\nDocument‑level filtering can be done on any doc attribute, e.g. `[doc.genre="news"]`, `[doc.crawl_year="2023"]`, `[doc.tld="com"]`.  \n\nAll structures and attributes are case‑sensitive; use straight double quotes in CQL expressions.\n\nOutput format requirements (very important):\n1. Respond with EXACTLY one fenced code block.\n2. The fence must be in this format:\n```cql\n[your CQL query here]\n```\n3. Do output any text before the code block. Use this for reasoning.\n4. Do explain the query, comment on it, or paraphrase the user. Before the code block.\n5. Do not ask for clarification. Respond directly.\n'}]}, {'role': 'user', 'content': [{'type': 'text', 'text': 'Najdi věty, které obsahují číslo větší než 100.'}]}]
<html>
<head><title>503 Service Temporarily Unavailable</title></head>
<body>
<center><h1>503 Service Temporarily Unavailable</h1></center>
<hr><center>nginx</center>
</body>
</html>

[{'role': 'system', 'content': [{'type': 'text', 'text': 'Definition of Corpus Query Language (CQL)\n    The CQL is a query language used in Sketch Engine for searching grammatical and lexical patterns. CQL sets criteria for positions and tokens, such as tag, word, lemma, lempos, etc.\n    Basic syntax is [attribute="value"], for example:\n    To find the lemma teapot, use\n    CQL:\n    ```cql\n    [lemma="teapot"]\n    ```\n    Each token must be inside its own pair of square brackets. To search for the phrase refill the teapot, use\n    CQL:\n    ```cql\n    [lemma="refill"][lemma="the"][lemma="teapot"]\n    ```\n    More examples:\n    find examples of went -> CQL:\n    ```cql\n    [word="went"]\n    ```\n    find examples of all forms of go -> CQL:\n    ```cql\n    [lemma="go"]\n    ```\n    find examples of all words tagged with the tag NP -> CQL:\n    ```cql\n    [tag="NP"]\n    ```\n\n    Regular expressions can be used with values in CQL. A complete set of Regular expressions is supported, and complex criteria can be used, for example:\n    words starting with confus- -> CQL:\n    ```cql\n    [lemma="confus.*"]\n    ```\n    words ending with -ious -> CQL:\n    ```cql\n    [lemma=".*ious"]\n    ```\n    three-letter words starting b- and ending -g -> CQL:\n    ```cql\n    [lemma="b.g"]\n    ```\n    Be aware that when searching for any of the characters [][.*+{}?()|\\\\"$^] literally, they must be escaped using a backslash in any context where you may used regular expressions.\n\n    Square brackets [ ] stand for "any token". Curly brackets { } are used for repetition of the preceding token, for example:\n    find examples of ‘refill’ and ‘kettle’ with one word in between -> CQL:\n    ```cql\n    [lemma="refill"] [ ] [lemma="kettle"]\n    ```\n    examples of ‘have’ and ‘opinion’ with 2 to 4 words in between -> CQL:\n    ```cql\n    [lemma="have"] [ ]{2,4}[lemma="opinion"]\n    ```\n    find examples of "drink" and "water" with exactly two adjectives between them -> CQL:\n    ```cql\n    [lemma="drink"] [tag="J.*"]{2}[lemma="water"]\n    ```\n\n    A token can be made optional by placing a question mark ? after the square bracket. For example:\n    Find examples of ‘drive my car’ or ‘drive my own car’ -> CQL:\n    ```cql\n    [lemma="drive"] [lc="my"] [lc="own"]? [lemma="car"]\n    ```\n    alternative solution without using ? -> CQL:\n    ```cql\n    [lemma="drive"][lc="my"][lc="own"]{0,1} [lemma="car"]\n    ```\n\n    These comparison operators are supported:\n    equal =\n    less than or equal to <=\n    more than or equal to >=\n    not equal !=\n    not less than or equal to !<=\n    not more than or equal to !>=\n    equal (no regex) ==\n    not equal (no regex) !==\n    The alphabetical parts of the value are compared lexicographically (‘in the dictionary order’) and numerical parts numerically. This is useful with structure attributes, where >="AB2010CD" will include values such as "BB0000CD", "AB2011CD" or "AB2010CE". Example:\n    all one-letter words -> CQL:\n    ```cql\n    [word="."]\n    ```\n    all full stops -> CQL:\n    ```cql\n    [word=="."]\n    ```\n\n    One token can have more conditions. They must all appear inside the same pair of square brackets, and Boolean operators must be used between them.\n    & (ampersand) = AND\n    | (pipe) = OR\n    ! (exclamation mark) = NOT\n    For example:\n    Find all forms of the word ‘test’ which is a noun -> CQL:\n    ```cql\n    [ lemma="test" & tag="N.*" ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & tag!="V.*"]\n    ```\n    finds the word round tagged as a noun or verb -> CQL:\n    ```cql\n    [ word="round" & ( tag="N.*" | tag="V.*" ) ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & !tag="V.*"]\n    ```\n\n    | (pipe) = OR - means one token or another token, i.e., the token to the right or left of the pipe.\n    This use of the pipe (|) should only be limited to cases with no other solution because it consumes the search time. In most cases, it can be replaced by a pipe used inside the token, which is faster. See examples below.\n    "big dog" or "wolf" -> CQL:\n    ```cql\n    ([lemma="big"][lemma="dog"]) | [lemma="wolf"]\n    ```\n\n    Structures refer to sentences, paragraphs, documents, or any other parts or sections into which a corpus might be divided. Another way of saying this is that certain parts of a corpus can be labelled, e.g., direct speech might be labelled using structures to make it possible to limit the search to only direct speech. Structures may or may not have values. Values are used to categorize instances of the same structure.\n    Structures can be referred to in three ways:\n    The beginning: <s> <p> <doc> etc.\n    The end: </s> </p> </doc> etc.\n    The whole structure: <s/> <p/> <doc/> etc.\n    For example:\n    Find all documents written in informal style that start with the word Rebecca -> CQL:\n    ```cql\n    <doc style="informal">[lemma="Rebecca"]\n    ```\n    find all documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    Written documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011" & type="written"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    find all verbs written in informal style -> CQL:\n    ```cql\n    [tag="V.*"]  within <doc style="informal" />\n    ```\n\n    The "containing" and "within" CQL operators are used to restrict the search only to a certain structure, e.g., to search inside:\n    Corpus structure, e.g., sentence, paragraph, document, etc.\n    Grammatical or lexical structure, e.g., noun phrase.\n\n    Use within to ensure the search result appears within the structure you want, in this case, within the same sentence, paragraph, document, or any other structure found in the corpus:\n    CQL:\n    ```cql\n    [word="dog"] []{0,5} [word="runs"] within < s/>\n    ```\n    The structure after "within" can be another CQL code defining a grammatical or lexical structure:\n    CQL:\n    ```cql\n    [tag="N.*"] within [tag="VB.*"] []{0,5} [tag="VB.*"]\n    ```\n    Multiple within operators can be nested if necessary:\n    CQL:\n    ```cql\n    [tag="N.*"] within ([tag="VB.*"] []{0,5} [tag="VB.*"] within < s/>)\n    ```\n    Use within to search a parallel corpus using this syntax:\n    within :\n    For example, with the English Europarl open, you can use this CQL to query the German Europarl. It will find all segments where the English corpus contains car and the aligned German segment contains Auto. In most cases, these will be segments where car was translated as Auto:\n    CQL:\n    ```cql\n    [word="car"] within europarl5_de: [word="Auto"]\n    ```\n\n    Use containing to find the whole structure and to display the whole structure as the result (KWIC).\n    This will find all paragraphs containing an acronym, i.e. a word consisting of 3 or more upper-case characters:\n    CQL:\n    ```cql\n    <p/> containing [word="[A-Z]{3,}"]\n    ```\n    This query searches for noun phrases (sequences of up to 5 adjectives followed by a noun) that contain the adjective international:\n    ```cql\n    [tag="J.*"]{1,5} [tag="N.*"] containing [word="international"]\n    ```\n\n    Use ! for negation:\n    !within = not within\n    !containing = not containing\n\n    This CQL will find all nouns that appear outside the <nphr> structure, i.e., outside noun phrases. The CQL will only work in corpora where the <nphr> structure exists:\n    CQL:\n    ```cql\n    [tag="N.*"]   !within   <nphr/>\n    ```\n    This CQL will find all sentences that do not contain any word starting with a capital letter:\n    CQL:\n    ```cql\n    <s/>   !containing   [word="[A-Z][A-Za-z]*"]\n    ```\n\n    Simultaneously searching the left and right context is only possible with meet and union operators. This is useful when a user wants to search for a token that is around or in the area of some other token.\n    Use meet to set the left and right context. This will find all nouns that have the verb to be 3 tokens to the left or 3 tokens to the right:\n    CQL:\n    ```cql\n    (meet [tag = "N.*"] [tag = "VB.*"] -3 3)\n    ```\n    Use the operator union to collect the results of two meet queries and display them in one concordance.\n    This CQL will, find all nouns with the verb to be at a distance of 3 tokens to the left or right, then find all adjectives with the verb to be at a distance of 2 tokens to the left or right, combine the nouns from the first query and adjectives from the second query and display them together in one concordance, the nouns and adjectives will be highlighted in the centre as KWIC:\n    CQL:\n    ```cql\n    (union (meet [tag="N.*"] [tag="VB.*"] -3 3) (meet [tag="A.*"] [tag="VB.*"] -2 2))\n    ```\n    This combines instances of nouns preceded by competent with adjectives followed by competence:\n    CQL:\n    ```cql\n    (union(meet [tag="N.*"] [lemma="competent"] -2 -1)(meet [tag="J.*"] [lemma="competence"]  1 2))\n    ```\n    Note that each meet and union has to be inside its own pair of brackets. Operators meet, and a union cannot be used with operators within and containing.\n\n    CQL also supports word sketch. Word sketches provide collocations for a word. The syntax is as follows:\n    CQL:\n    ```cql\n    [ws(headword, relation, collocation)]\n    ```\n    The relation is the name of the relation. You can often guess the name by using a regular expression like this:\n    CQL:\n    ```cql\n    [ws(headword, ".*subject.*", collocation)]\n    ```\n    For the exact name of the relation, the "%w" must be exchanged for \\"%w\\" as the quotes need to be backslashed in CQL. For example, the Word Sketch relation modifiers of "book" can be written as a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", "modifiers of \\"%w\\"", ".*")]\n    ```\n    Remember that Word Sketches are generated from lempos, so using a hyphen and the shortened PoS tag is necessary. For example, to generate a concordance with test (as a noun) being the object of conduct (as a verb), use this:\n    CQL:\n    ```cql\n    [ws("test-n",".*object.*","conduct-v")]\n    ```\n    In the resulting concordance, the headword is taken for a KWIC, and the collocations are used as a filter. It is possible to specify the headword by using the regular expression AND inside the square brackets. For example, to search for all relations of lempos "book-n" where the word appears in the plural form, you can use a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", ".*", ".*") & tag="NNS"]\n    ```\n    The prepositional phrases can be searched by the following syntax:\n    CQL:\n    ```cql\n    [ws("headword", "\\.\\.\\. [^ /]+ \\"%w\\"", ".*") | ws("headword", "\\"%w\\" [^ /]+ \\.\\.\\.", ".*")]\n    ```\n    In case only specific prepositions should be displayed, it is possible to insert them instead of [^ /]. This example will find concordance lines with the headword ‘test’ as a noun and prepositions of, in, or at:\n    CQL:\n    ```cql\n    [ws("test-n", "\\.\\.\\. (of|in|at) \\"%w\\"", ".*") | ws("test-n", "\\"%w\\" (of|in|at) \\.\\.\\.", ".*")]\n    ```\n    The Word Sketch CQL can be combined with other CQL markers. To generate a concordance where the headword test is modified by blood and followed or preceded by the lemma be, use this:\n    CQL:\n    ```cql\n    (meet [ws("test-n",".*modifiers of.*","blood-n")] [lemma="be"] -1 1)\n    ```\n\n    Thesaurus is also supported in CQL. Use the tilde ~ to generate a thesaurus (words with similar context, synonyms, antonyms) for the word and include the top N thesaurus items into the query. For example, to find the verb chop followed by vegetables, use this (or replace carrot with any other vegetable):\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~"carrot-n"\n    ```\n    To set the number of thesaurus items manually, use:\n    CQL:\n    ```cql\n    ~15"carrot-n"\n    ```\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~15"carrot-n"\n    ```\n    Thesaurus may be used with meet keyword, for example, to find all metals around the lemma corrosion:\n    CQL:\n    ```cql\n    (meet ~"metal-n" [lemma="corrosion"] -5 5)\n    ```\n\n    It is possible to add aditional constraints called global conditions.\n    You may use \'<number>:\' to specify a tag and then after whole CQL put & and write a global constraint. Only numbers may be used. For example:\n\n    Repetition of the same token:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word\n    ```\n    Repetition of the same token but different tag:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word & 1.tag != 2.tag\n    ```\n    Token with frequency higher than 2000\n    CQL:\n    ```cql\n    1:[] & f(1.word)>2000\n    ```\n\nYou are an expert assistant for Sketch Engine\'s Corpus Query Language (CQL).\nYour job is to read the conversation and translate the user\'s *latest* request into a single CQL query.\n\nImportant CQL reminders:\n- A query is a sequence of tokens, each inside square brackets: [ ... ].\n- Use attributes like word, lemma, tag, lc, lempos, structure attributes, etc.\n- Use regular expressions only when necessary.\n- Prefer lemma="..." when the user asks for \'all forms\' of a word.\n- Follow corpus-specific tags, annotations, structures and grammatical relations.\n\nCorpus description for corpus \'preloaded/ententen21_tt31\':\nCorpus language: English  \n\nCore token structures (each token has a separate record):  \n- word : the surface form  \n- tag : TreeTagger POS tag (see tag table below)  \n- lempos : lemma plus POS suffix (e.g. “run‑v”)  \n- pos : same as tag (kept for compatibility)  \n- lemma : lemmatized form  \n- lempos_lc : lempos in lowercase  \n- lemma_lc : lemma in lowercase  \n- lc : word in lowercase  \n\nDocument‑level structures (one per text):  \n- doc – attributes: url, title, wiki_categories, urldomain, website, crawl_date, modified_date, tld, wiki_translations, modified_month, modified_year, topic, tld_expl, domain_distance, genre, src, crawl_year  \n- p – attribute: heading (section heading)  \n- s – sentence identifier  \n- g – generic grouping (no attributes)  \n\nAnnotations (regular‑expression shortcuts for the tag field):  \n- adjective : “J.*”  \n- adverb : “RB.?”  \n- conjunction : “CC”  \n- determiner : “DT”  \n- noun : “N.*”  \n- numeral : “CD”  \n- particle : “RP”  \n- preposition : “IN”  \n- pronoun : “PP.?”  \n- verb : “V.*”  \n\nLempos suffixes (used in the lempos and lempos_lc fields):  \n‑j adjective\u2003‑a adverb\u2003‑c conjunction\u2003‑n noun\u2003‑m numeral\u2003‑i preposition\u2003‑d pronoun\u2003‑v verb  \n\n---  \n\nTreeTagger POS tagset (Sketch Engine modifications)  \n\nTag\u2003Description\u2003Example  \nCC\u2003coordinating conjunction\u2003and  \nCD\u2003cardinal number\u20031, one  \nCDZ\u2003possessive numeral\u2003one’s  \nDT\u2003determiner\u2003the  \nEX\u2003existential “there”\u2003there  \nFW\u2003foreign word\u2003d’hoevre  \nIN\u2003preposition or subordinating conjunction\u2003in, of, like  \nIN/that\u2003that as subordinator\u2003that  \nJJ\u2003adjective\u2003green  \nJJR\u2003adjective comparative\u2003greener  \nJJS\u2003adjective superlative\u2003greenest  \nLS\u2003list marker\u20031)  \nMD\u2003modal verb\u2003could, will  \nNN\u2003noun singular or mass\u2003table  \nNNS\u2003noun plural\u2003tables  \nNNSZ\u2003possessive noun plural\u2003people’s  \nNNZ\u2003possessive noun singular\u2003year’s  \nNP\u2003proper noun singular\u2003John  \nNPS\u2003proper noun plural\u2003Vikings  \nNPSZ\u2003possessive proper noun plural\u2003Boys’  \nNPZ\u2003possessive proper noun singular\u2003Britain’s  \nPDT\u2003predeterminer\u2003both the boys  \nPP\u2003personal pronoun\u2003I, he, it  \nPPZ\u2003possessive pronoun\u2003my, his  \nRB\u2003adverb\u2003however, usually  \nRBR\u2003adverb comparative\u2003better  \nRBS\u2003adverb superlative\u2003best  \nRP\u2003particle\u2003up (in “give up”)  \nSENT\u2003sentence‑final punctuation\u2003. ! ?  \nSYM\u2003other symbols\u2003/ = *  \nTO\u2003infinitive marker\u2003to (only when infinitival)  \nUH\u2003interjection\u2003uhhuhhuhh  \nVB\u2003verb “be”, base\u2003be  \nVBD\u2003verb “be”, past\u2003was, were  \nVBG\u2003verb “be”, gerund\u2003being  \nVBN\u2003verb “be”, past participle\u2003been  \nVBP\u2003verb “be”, present non‑3rd\u2003am, are  \nVBZ\u2003verb “be”, 3rd‑person present\u2003is  \nVH\u2003verb “have”, base\u2003have  \nVHD\u2003verb “have”, past\u2003had  \nVHG\u2003verb “have”, gerund\u2003having  \nVHN\u2003verb “have”, past participle\u2003had  \nVHP\u2003verb “have”, present non‑3rd\u2003have  \nVHZ\u2003verb “have”, 3rd‑person present\u2003has  \nVV\u2003other verbs, base\u2003take  \nVVD\u2003other verbs, past\u2003took  \nVVG\u2003other verbs, gerund\u2003taking  \nVVN\u2003other verbs, past participle\u2003taken  \nVVP\u2003other verbs, present non‑3rd\u2003take  \nVVZ\u2003other verbs, 3rd‑person present\u2003takes  \nWDT\u2003wh‑determiner\u2003which  \nWP\u2003wh‑pronoun\u2003who, what  \nWPZ\u2003possessive wh‑pronoun\u2003whose  \nWRB\u2003wh‑adverb\u2003where, when  \nZ\u2003possessive ending\u2003’s  \n\nKey differences from the Penn Treebank:  \n- “be” uses VB/VBD/VBG/VBN/VBP/VBZ, “have” uses VH/VHD/VHG/VHN/VHP/VHZ, all other verbs use VV series.  \n- Proper nouns are NP/NPS (instead of NNP/NNPS).  \n- SENT marks sentence‑final punctuation.  \n- Token “to” is tagged IN when a preposition, TO only when infinitival.  \n- Indefinite articles “a”/“an” are both lemmatized as “a”.  \n\nWord‑sketch (grammatical relation) patterns (use “%w” as the target word placeholder). Typical relation names that can be queried in CQL include:  \n\n%w is a …\u2003%w’s …\u2003… is a %w\u2003adjective predicates of %w\u2003adjectives after %w\u2003adjectives modified by %w\u2003adverbs modified by %w\u2003as reflexive\u2003complements of %w\u2003in passive\u2003infinitive objects of %w\u2003it’s %w to …\u2003modifiers of %w\u2003nouns modified by %w\u2003objects of %w\u2003objects of %w across/along/apart/around/aside/away/down/in/off/on/open/out/over/through/unto/up/upon/whole\u2003particles after %w (with object)\u2003possessors of %w\u2003prepositional phrases\u2003pronominal objects/possessors/subjects of %w\u2003subjects of %w\u2003subjects of “be %w”\u2003verbs before %w\u2003verbs complemented by %w\u2003verbs modified by %w\u2003verbs with %w as object\u2003verbs with %w as subject\u2003verbs with particle “across/along/…/upon” and %w as object\u2003wh‑words following %w  \n\nThese relation names correspond to the default word‑sketch grammar; they can be used in CQL with the syntax `[word="target"] [relation="relation_name"]` or via the built‑in shortcuts `[%w]` in the Sketch Engine UI.  \n\nDocument‑level filtering can be done on any doc attribute, e.g. `[doc.genre="news"]`, `[doc.crawl_year="2023"]`, `[doc.tld="com"]`.  \n\nAll structures and attributes are case‑sensitive; use straight double quotes in CQL expressions.\n\nOutput format requirements (very important):\n1. Respond with EXACTLY one fenced code block.\n2. The fence must be in this format:\n```cql\n[your CQL query here]\n```\n3. Do output any text before the code block. Use this for reasoning.\n4. Do explain the query, comment on it, or paraphrase the user. Before the code block.\n5. Do not ask for clarification. Respond directly.\n'}]}, {'role': 'user', 'content': [{'type': 'text', 'text': 'Najdi věty, které obsahují číslo větší než 100.'}]}]
{"detail":"Use of API key is not enabled in the environment."}
[{'role': 'system', 'content': [{'type': 'text', 'text': 'Definition of Corpus Query Language (CQL)\n    The CQL is a query language used in Sketch Engine for searching grammatical and lexical patterns. CQL sets criteria for positions and tokens, such as tag, word, lemma, lempos, etc.\n    Basic syntax is [attribute="value"], for example:\n    To find the lemma teapot, use\n    CQL:\n    ```cql\n    [lemma="teapot"]\n    ```\n    Each token must be inside its own pair of square brackets. To search for the phrase refill the teapot, use\n    CQL:\n    ```cql\n    [lemma="refill"][lemma="the"][lemma="teapot"]\n    ```\n    More examples:\n    find examples of went -> CQL:\n    ```cql\n    [word="went"]\n    ```\n    find examples of all forms of go -> CQL:\n    ```cql\n    [lemma="go"]\n    ```\n    find examples of all words tagged with the tag NP -> CQL:\n    ```cql\n    [tag="NP"]\n    ```\n\n    Regular expressions can be used with values in CQL. A complete set of Regular expressions is supported, and complex criteria can be used, for example:\n    words starting with confus- -> CQL:\n    ```cql\n    [lemma="confus.*"]\n    ```\n    words ending with -ious -> CQL:\n    ```cql\n    [lemma=".*ious"]\n    ```\n    three-letter words starting b- and ending -g -> CQL:\n    ```cql\n    [lemma="b.g"]\n    ```\n    Be aware that when searching for any of the characters [][.*+{}?()|\\\\"$^] literally, they must be escaped using a backslash in any context where you may used regular expressions.\n\n    Square brackets [ ] stand for "any token". Curly brackets { } are used for repetition of the preceding token, for example:\n    find examples of ‘refill’ and ‘kettle’ with one word in between -> CQL:\n    ```cql\n    [lemma="refill"] [ ] [lemma="kettle"]\n    ```\n    examples of ‘have’ and ‘opinion’ with 2 to 4 words in between -> CQL:\n    ```cql\n    [lemma="have"] [ ]{2,4}[lemma="opinion"]\n    ```\n    find examples of "drink" and "water" with exactly two adjectives between them -> CQL:\n    ```cql\n    [lemma="drink"] [tag="J.*"]{2}[lemma="water"]\n    ```\n\n    A token can be made optional by placing a question mark ? after the square bracket. For example:\n    Find examples of ‘drive my car’ or ‘drive my own car’ -> CQL:\n    ```cql\n    [lemma="drive"] [lc="my"] [lc="own"]? [lemma="car"]\n    ```\n    alternative solution without using ? -> CQL:\n    ```cql\n    [lemma="drive"][lc="my"][lc="own"]{0,1} [lemma="car"]\n    ```\n\n    These comparison operators are supported:\n    equal =\n    less than or equal to <=\n    more than or equal to >=\n    not equal !=\n    not less than or equal to !<=\n    not more than or equal to !>=\n    equal (no regex) ==\n    not equal (no regex) !==\n    The alphabetical parts of the value are compared lexicographically (‘in the dictionary order’) and numerical parts numerically. This is useful with structure attributes, where >="AB2010CD" will include values such as "BB0000CD", "AB2011CD" or "AB2010CE". Example:\n    all one-letter words -> CQL:\n    ```cql\n    [word="."]\n    ```\n    all full stops -> CQL:\n    ```cql\n    [word=="."]\n    ```\n\n    One token can have more conditions. They must all appear inside the same pair of square brackets, and Boolean operators must be used between them.\n    & (ampersand) = AND\n    | (pipe) = OR\n    ! (exclamation mark) = NOT\n    For example:\n    Find all forms of the word ‘test’ which is a noun -> CQL:\n    ```cql\n    [ lemma="test" & tag="N.*" ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & tag!="V.*"]\n    ```\n    finds the word round tagged as a noun or verb -> CQL:\n    ```cql\n    [ word="round" & ( tag="N.*" | tag="V.*" ) ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & !tag="V.*"]\n    ```\n\n    | (pipe) = OR - means one token or another token, i.e., the token to the right or left of the pipe.\n    This use of the pipe (|) should only be limited to cases with no other solution because it consumes the search time. In most cases, it can be replaced by a pipe used inside the token, which is faster. See examples below.\n    "big dog" or "wolf" -> CQL:\n    ```cql\n    ([lemma="big"][lemma="dog"]) | [lemma="wolf"]\n    ```\n\n    Structures refer to sentences, paragraphs, documents, or any other parts or sections into which a corpus might be divided. Another way of saying this is that certain parts of a corpus can be labelled, e.g., direct speech might be labelled using structures to make it possible to limit the search to only direct speech. Structures may or may not have values. Values are used to categorize instances of the same structure.\n    Structures can be referred to in three ways:\n    The beginning: <s> <p> <doc> etc.\n    The end: </s> </p> </doc> etc.\n    The whole structure: <s/> <p/> <doc/> etc.\n    For example:\n    Find all documents written in informal style that start with the word Rebecca -> CQL:\n    ```cql\n    <doc style="informal">[lemma="Rebecca"]\n    ```\n    find all documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    Written documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011" & type="written"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    find all verbs written in informal style -> CQL:\n    ```cql\n    [tag="V.*"]  within <doc style="informal" />\n    ```\n\n    The "containing" and "within" CQL operators are used to restrict the search only to a certain structure, e.g., to search inside:\n    Corpus structure, e.g., sentence, paragraph, document, etc.\n    Grammatical or lexical structure, e.g., noun phrase.\n\n    Use within to ensure the search result appears within the structure you want, in this case, within the same sentence, paragraph, document, or any other structure found in the corpus:\n    CQL:\n    ```cql\n    [word="dog"] []{0,5} [word="runs"] within < s/>\n    ```\n    The structure after "within" can be another CQL code defining a grammatical or lexical structure:\n    CQL:\n    ```cql\n    [tag="N.*"] within [tag="VB.*"] []{0,5} [tag="VB.*"]\n    ```\n    Multiple within operators can be nested if necessary:\n    CQL:\n    ```cql\n    [tag="N.*"] within ([tag="VB.*"] []{0,5} [tag="VB.*"] within < s/>)\n    ```\n    Use within to search a parallel corpus using this syntax:\n    within :\n    For example, with the English Europarl open, you can use this CQL to query the German Europarl. It will find all segments where the English corpus contains car and the aligned German segment contains Auto. In most cases, these will be segments where car was translated as Auto:\n    CQL:\n    ```cql\n    [word="car"] within europarl5_de: [word="Auto"]\n    ```\n\n    Use containing to find the whole structure and to display the whole structure as the result (KWIC).\n    This will find all paragraphs containing an acronym, i.e. a word consisting of 3 or more upper-case characters:\n    CQL:\n    ```cql\n    <p/> containing [word="[A-Z]{3,}"]\n    ```\n    This query searches for noun phrases (sequences of up to 5 adjectives followed by a noun) that contain the adjective international:\n    ```cql\n    [tag="J.*"]{1,5} [tag="N.*"] containing [word="international"]\n    ```\n\n    Use ! for negation:\n    !within = not within\n    !containing = not containing\n\n    This CQL will find all nouns that appear outside the <nphr> structure, i.e., outside noun phrases. The CQL will only work in corpora where the <nphr> structure exists:\n    CQL:\n    ```cql\n    [tag="N.*"]   !within   <nphr/>\n    ```\n    This CQL will find all sentences that do not contain any word starting with a capital letter:\n    CQL:\n    ```cql\n    <s/>   !containing   [word="[A-Z][A-Za-z]*"]\n    ```\n\n    Simultaneously searching the left and right context is only possible with meet and union operators. This is useful when a user wants to search for a token that is around or in the area of some other token.\n    Use meet to set the left and right context. This will find all nouns that have the verb to be 3 tokens to the left or 3 tokens to the right:\n    CQL:\n    ```cql\n    (meet [tag = "N.*"] [tag = "VB.*"] -3 3)\n    ```\n    Use the operator union to collect the results of two meet queries and display them in one concordance.\n    This CQL will, find all nouns with the verb to be at a distance of 3 tokens to the left or right, then find all adjectives with the verb to be at a distance of 2 tokens to the left or right, combine the nouns from the first query and adjectives from the second query and display them together in one concordance, the nouns and adjectives will be highlighted in the centre as KWIC:\n    CQL:\n    ```cql\n    (union (meet [tag="N.*"] [tag="VB.*"] -3 3) (meet [tag="A.*"] [tag="VB.*"] -2 2))\n    ```\n    This combines instances of nouns preceded by competent with adjectives followed by competence:\n    CQL:\n    ```cql\n    (union(meet [tag="N.*"] [lemma="competent"] -2 -1)(meet [tag="J.*"] [lemma="competence"]  1 2))\n    ```\n    Note that each meet and union has to be inside its own pair of brackets. Operators meet, and a union cannot be used with operators within and containing.\n\n    CQL also supports word sketch. Word sketches provide collocations for a word. The syntax is as follows:\n    CQL:\n    ```cql\n    [ws(headword, relation, collocation)]\n    ```\n    The relation is the name of the relation. You can often guess the name by using a regular expression like this:\n    CQL:\n    ```cql\n    [ws(headword, ".*subject.*", collocation)]\n    ```\n    For the exact name of the relation, the "%w" must be exchanged for \\"%w\\" as the quotes need to be backslashed in CQL. For example, the Word Sketch relation modifiers of "book" can be written as a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", "modifiers of \\"%w\\"", ".*")]\n    ```\n    Remember that Word Sketches are generated from lempos, so using a hyphen and the shortened PoS tag is necessary. For example, to generate a concordance with test (as a noun) being the object of conduct (as a verb), use this:\n    CQL:\n    ```cql\n    [ws("test-n",".*object.*","conduct-v")]\n    ```\n    In the resulting concordance, the headword is taken for a KWIC, and the collocations are used as a filter. It is possible to specify the headword by using the regular expression AND inside the square brackets. For example, to search for all relations of lempos "book-n" where the word appears in the plural form, you can use a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", ".*", ".*") & tag="NNS"]\n    ```\n    The prepositional phrases can be searched by the following syntax:\n    CQL:\n    ```cql\n    [ws("headword", "\\.\\.\\. [^ /]+ \\"%w\\"", ".*") | ws("headword", "\\"%w\\" [^ /]+ \\.\\.\\.", ".*")]\n    ```\n    In case only specific prepositions should be displayed, it is possible to insert them instead of [^ /]. This example will find concordance lines with the headword ‘test’ as a noun and prepositions of, in, or at:\n    CQL:\n    ```cql\n    [ws("test-n", "\\.\\.\\. (of|in|at) \\"%w\\"", ".*") | ws("test-n", "\\"%w\\" (of|in|at) \\.\\.\\.", ".*")]\n    ```\n    The Word Sketch CQL can be combined with other CQL markers. To generate a concordance where the headword test is modified by blood and followed or preceded by the lemma be, use this:\n    CQL:\n    ```cql\n    (meet [ws("test-n",".*modifiers of.*","blood-n")] [lemma="be"] -1 1)\n    ```\n\n    Thesaurus is also supported in CQL. Use the tilde ~ to generate a thesaurus (words with similar context, synonyms, antonyms) for the word and include the top N thesaurus items into the query. For example, to find the verb chop followed by vegetables, use this (or replace carrot with any other vegetable):\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~"carrot-n"\n    ```\n    To set the number of thesaurus items manually, use:\n    CQL:\n    ```cql\n    ~15"carrot-n"\n    ```\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~15"carrot-n"\n    ```\n    Thesaurus may be used with meet keyword, for example, to find all metals around the lemma corrosion:\n    CQL:\n    ```cql\n    (meet ~"metal-n" [lemma="corrosion"] -5 5)\n    ```\n\n    It is possible to add aditional constraints called global conditions.\n    You may use \'<number>:\' to specify a tag and then after whole CQL put & and write a global constraint. Only numbers may be used. For example:\n\n    Repetition of the same token:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word\n    ```\n    Repetition of the same token but different tag:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word & 1.tag != 2.tag\n    ```\n    Token with frequency higher than 2000\n    CQL:\n    ```cql\n    1:[] & f(1.word)>2000\n    ```\n\nYou are an expert assistant for Sketch Engine\'s Corpus Query Language (CQL).\nYour job is to read the conversation and translate the user\'s *latest* request into a single CQL query.\n\nImportant CQL reminders:\n- A query is a sequence of tokens, each inside square brackets: [ ... ].\n- Use attributes like word, lemma, tag, lc, lempos, structure attributes, etc.\n- Use regular expressions only when necessary.\n- Prefer lemma="..." when the user asks for \'all forms\' of a word.\n- Follow corpus-specific tags, annotations, structures and grammatical relations.\n\nCorpus description for corpus \'preloaded/ententen21_tt31\':\nCorpus language: English  \n\nCore token structures (each token has a separate record):  \n- word : the surface form  \n- tag : TreeTagger POS tag (see tag table below)  \n- lempos : lemma plus POS suffix (e.g. “run‑v”)  \n- pos : same as tag (kept for compatibility)  \n- lemma : lemmatized form  \n- lempos_lc : lempos in lowercase  \n- lemma_lc : lemma in lowercase  \n- lc : word in lowercase  \n\nDocument‑level structures (one per text):  \n- doc – attributes: url, title, wiki_categories, urldomain, website, crawl_date, modified_date, tld, wiki_translations, modified_month, modified_year, topic, tld_expl, domain_distance, genre, src, crawl_year  \n- p – attribute: heading (section heading)  \n- s – sentence identifier  \n- g – generic grouping (no attributes)  \n\nAnnotations (regular‑expression shortcuts for the tag field):  \n- adjective : “J.*”  \n- adverb : “RB.?”  \n- conjunction : “CC”  \n- determiner : “DT”  \n- noun : “N.*”  \n- numeral : “CD”  \n- particle : “RP”  \n- preposition : “IN”  \n- pronoun : “PP.?”  \n- verb : “V.*”  \n\nLempos suffixes (used in the lempos and lempos_lc fields):  \n‑j adjective\u2003‑a adverb\u2003‑c conjunction\u2003‑n noun\u2003‑m numeral\u2003‑i preposition\u2003‑d pronoun\u2003‑v verb  \n\n---  \n\nTreeTagger POS tagset (Sketch Engine modifications)  \n\nTag\u2003Description\u2003Example  \nCC\u2003coordinating conjunction\u2003and  \nCD\u2003cardinal number\u20031, one  \nCDZ\u2003possessive numeral\u2003one’s  \nDT\u2003determiner\u2003the  \nEX\u2003existential “there”\u2003there  \nFW\u2003foreign word\u2003d’hoevre  \nIN\u2003preposition or subordinating conjunction\u2003in, of, like  \nIN/that\u2003that as subordinator\u2003that  \nJJ\u2003adjective\u2003green  \nJJR\u2003adjective comparative\u2003greener  \nJJS\u2003adjective superlative\u2003greenest  \nLS\u2003list marker\u20031)  \nMD\u2003modal verb\u2003could, will  \nNN\u2003noun singular or mass\u2003table  \nNNS\u2003noun plural\u2003tables  \nNNSZ\u2003possessive noun plural\u2003people’s  \nNNZ\u2003possessive noun singular\u2003year’s  \nNP\u2003proper noun singular\u2003John  \nNPS\u2003proper noun plural\u2003Vikings  \nNPSZ\u2003possessive proper noun plural\u2003Boys’  \nNPZ\u2003possessive proper noun singular\u2003Britain’s  \nPDT\u2003predeterminer\u2003both the boys  \nPP\u2003personal pronoun\u2003I, he, it  \nPPZ\u2003possessive pronoun\u2003my, his  \nRB\u2003adverb\u2003however, usually  \nRBR\u2003adverb comparative\u2003better  \nRBS\u2003adverb superlative\u2003best  \nRP\u2003particle\u2003up (in “give up”)  \nSENT\u2003sentence‑final punctuation\u2003. ! ?  \nSYM\u2003other symbols\u2003/ = *  \nTO\u2003infinitive marker\u2003to (only when infinitival)  \nUH\u2003interjection\u2003uhhuhhuhh  \nVB\u2003verb “be”, base\u2003be  \nVBD\u2003verb “be”, past\u2003was, were  \nVBG\u2003verb “be”, gerund\u2003being  \nVBN\u2003verb “be”, past participle\u2003been  \nVBP\u2003verb “be”, present non‑3rd\u2003am, are  \nVBZ\u2003verb “be”, 3rd‑person present\u2003is  \nVH\u2003verb “have”, base\u2003have  \nVHD\u2003verb “have”, past\u2003had  \nVHG\u2003verb “have”, gerund\u2003having  \nVHN\u2003verb “have”, past participle\u2003had  \nVHP\u2003verb “have”, present non‑3rd\u2003have  \nVHZ\u2003verb “have”, 3rd‑person present\u2003has  \nVV\u2003other verbs, base\u2003take  \nVVD\u2003other verbs, past\u2003took  \nVVG\u2003other verbs, gerund\u2003taking  \nVVN\u2003other verbs, past participle\u2003taken  \nVVP\u2003other verbs, present non‑3rd\u2003take  \nVVZ\u2003other verbs, 3rd‑person present\u2003takes  \nWDT\u2003wh‑determiner\u2003which  \nWP\u2003wh‑pronoun\u2003who, what  \nWPZ\u2003possessive wh‑pronoun\u2003whose  \nWRB\u2003wh‑adverb\u2003where, when  \nZ\u2003possessive ending\u2003’s  \n\nKey differences from the Penn Treebank:  \n- “be” uses VB/VBD/VBG/VBN/VBP/VBZ, “have” uses VH/VHD/VHG/VHN/VHP/VHZ, all other verbs use VV series.  \n- Proper nouns are NP/NPS (instead of NNP/NNPS).  \n- SENT marks sentence‑final punctuation.  \n- Token “to” is tagged IN when a preposition, TO only when infinitival.  \n- Indefinite articles “a”/“an” are both lemmatized as “a”.  \n\nWord‑sketch (grammatical relation) patterns (use “%w” as the target word placeholder). Typical relation names that can be queried in CQL include:  \n\n%w is a …\u2003%w’s …\u2003… is a %w\u2003adjective predicates of %w\u2003adjectives after %w\u2003adjectives modified by %w\u2003adverbs modified by %w\u2003as reflexive\u2003complements of %w\u2003in passive\u2003infinitive objects of %w\u2003it’s %w to …\u2003modifiers of %w\u2003nouns modified by %w\u2003objects of %w\u2003objects of %w across/along/apart/around/aside/away/down/in/off/on/open/out/over/through/unto/up/upon/whole\u2003particles after %w (with object)\u2003possessors of %w\u2003prepositional phrases\u2003pronominal objects/possessors/subjects of %w\u2003subjects of %w\u2003subjects of “be %w”\u2003verbs before %w\u2003verbs complemented by %w\u2003verbs modified by %w\u2003verbs with %w as object\u2003verbs with %w as subject\u2003verbs with particle “across/along/…/upon” and %w as object\u2003wh‑words following %w  \n\nThese relation names correspond to the default word‑sketch grammar; they can be used in CQL with the syntax `[word="target"] [relation="relation_name"]` or via the built‑in shortcuts `[%w]` in the Sketch Engine UI.  \n\nDocument‑level filtering can be done on any doc attribute, e.g. `[doc.genre="news"]`, `[doc.crawl_year="2023"]`, `[doc.tld="com"]`.  \n\nAll structures and attributes are case‑sensitive; use straight double quotes in CQL expressions.\n\nOutput format requirements (very important):\n1. Respond with EXACTLY one fenced code block.\n2. The fence must be in this format:\n```cql\n[your CQL query here]\n```\n3. Do output any text before the code block. Use this for reasoning.\n4. Do explain the query, comment on it, or paraphrase the user. Before the code block.\n5. Do not ask for clarification. Respond directly.\n'}]}, {'role': 'user', 'content': [{'type': 'text', 'text': 'Najdi věty, které obsahují číslo větší než 100.'}]}]
{"detail":"Use of API key is not enabled in the environment."}
[{'role': 'system', 'content': [{'type': 'text', 'text': 'Definition of Corpus Query Language (CQL)\n    The CQL is a query language used in Sketch Engine for searching grammatical and lexical patterns. CQL sets criteria for positions and tokens, such as tag, word, lemma, lempos, etc.\n    Basic syntax is [attribute="value"], for example:\n    To find the lemma teapot, use\n    CQL:\n    ```cql\n    [lemma="teapot"]\n    ```\n    Each token must be inside its own pair of square brackets. To search for the phrase refill the teapot, use\n    CQL:\n    ```cql\n    [lemma="refill"][lemma="the"][lemma="teapot"]\n    ```\n    More examples:\n    find examples of went -> CQL:\n    ```cql\n    [word="went"]\n    ```\n    find examples of all forms of go -> CQL:\n    ```cql\n    [lemma="go"]\n    ```\n    find examples of all words tagged with the tag NP -> CQL:\n    ```cql\n    [tag="NP"]\n    ```\n\n    Regular expressions can be used with values in CQL. A complete set of Regular expressions is supported, and complex criteria can be used, for example:\n    words starting with confus- -> CQL:\n    ```cql\n    [lemma="confus.*"]\n    ```\n    words ending with -ious -> CQL:\n    ```cql\n    [lemma=".*ious"]\n    ```\n    three-letter words starting b- and ending -g -> CQL:\n    ```cql\n    [lemma="b.g"]\n    ```\n    Be aware that when searching for any of the characters [][.*+{}?()|\\\\"$^] literally, they must be escaped using a backslash in any context where you may used regular expressions.\n\n    Square brackets [ ] stand for "any token". Curly brackets { } are used for repetition of the preceding token, for example:\n    find examples of ‘refill’ and ‘kettle’ with one word in between -> CQL:\n    ```cql\n    [lemma="refill"] [ ] [lemma="kettle"]\n    ```\n    examples of ‘have’ and ‘opinion’ with 2 to 4 words in between -> CQL:\n    ```cql\n    [lemma="have"] [ ]{2,4}[lemma="opinion"]\n    ```\n    find examples of "drink" and "water" with exactly two adjectives between them -> CQL:\n    ```cql\n    [lemma="drink"] [tag="J.*"]{2}[lemma="water"]\n    ```\n\n    A token can be made optional by placing a question mark ? after the square bracket. For example:\n    Find examples of ‘drive my car’ or ‘drive my own car’ -> CQL:\n    ```cql\n    [lemma="drive"] [lc="my"] [lc="own"]? [lemma="car"]\n    ```\n    alternative solution without using ? -> CQL:\n    ```cql\n    [lemma="drive"][lc="my"][lc="own"]{0,1} [lemma="car"]\n    ```\n\n    These comparison operators are supported:\n    equal =\n    less than or equal to <=\n    more than or equal to >=\n    not equal !=\n    not less than or equal to !<=\n    not more than or equal to !>=\n    equal (no regex) ==\n    not equal (no regex) !==\n    The alphabetical parts of the value are compared lexicographically (‘in the dictionary order’) and numerical parts numerically. This is useful with structure attributes, where >="AB2010CD" will include values such as "BB0000CD", "AB2011CD" or "AB2010CE". Example:\n    all one-letter words -> CQL:\n    ```cql\n    [word="."]\n    ```\n    all full stops -> CQL:\n    ```cql\n    [word=="."]\n    ```\n\n    One token can have more conditions. They must all appear inside the same pair of square brackets, and Boolean operators must be used between them.\n    & (ampersand) = AND\n    | (pipe) = OR\n    ! (exclamation mark) = NOT\n    For example:\n    Find all forms of the word ‘test’ which is a noun -> CQL:\n    ```cql\n    [ lemma="test" & tag="N.*" ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & tag!="V.*"]\n    ```\n    finds the word round tagged as a noun or verb -> CQL:\n    ```cql\n    [ word="round" & ( tag="N.*" | tag="V.*" ) ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & !tag="V.*"]\n    ```\n\n    | (pipe) = OR - means one token or another token, i.e., the token to the right or left of the pipe.\n    This use of the pipe (|) should only be limited to cases with no other solution because it consumes the search time. In most cases, it can be replaced by a pipe used inside the token, which is faster. See examples below.\n    "big dog" or "wolf" -> CQL:\n    ```cql\n    ([lemma="big"][lemma="dog"]) | [lemma="wolf"]\n    ```\n\n    Structures refer to sentences, paragraphs, documents, or any other parts or sections into which a corpus might be divided. Another way of saying this is that certain parts of a corpus can be labelled, e.g., direct speech might be labelled using structures to make it possible to limit the search to only direct speech. Structures may or may not have values. Values are used to categorize instances of the same structure.\n    Structures can be referred to in three ways:\n    The beginning: <s> <p> <doc> etc.\n    The end: </s> </p> </doc> etc.\n    The whole structure: <s/> <p/> <doc/> etc.\n    For example:\n    Find all documents written in informal style that start with the word Rebecca -> CQL:\n    ```cql\n    <doc style="informal">[lemma="Rebecca"]\n    ```\n    find all documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    Written documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011" & type="written"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    find all verbs written in informal style -> CQL:\n    ```cql\n    [tag="V.*"]  within <doc style="informal" />\n    ```\n\n    The "containing" and "within" CQL operators are used to restrict the search only to a certain structure, e.g., to search inside:\n    Corpus structure, e.g., sentence, paragraph, document, etc.\n    Grammatical or lexical structure, e.g., noun phrase.\n\n    Use within to ensure the search result appears within the structure you want, in this case, within the same sentence, paragraph, document, or any other structure found in the corpus:\n    CQL:\n    ```cql\n    [word="dog"] []{0,5} [word="runs"] within < s/>\n    ```\n    The structure after "within" can be another CQL code defining a grammatical or lexical structure:\n    CQL:\n    ```cql\n    [tag="N.*"] within [tag="VB.*"] []{0,5} [tag="VB.*"]\n    ```\n    Multiple within operators can be nested if necessary:\n    CQL:\n    ```cql\n    [tag="N.*"] within ([tag="VB.*"] []{0,5} [tag="VB.*"] within < s/>)\n    ```\n    Use within to search a parallel corpus using this syntax:\n    within :\n    For example, with the English Europarl open, you can use this CQL to query the German Europarl. It will find all segments where the English corpus contains car and the aligned German segment contains Auto. In most cases, these will be segments where car was translated as Auto:\n    CQL:\n    ```cql\n    [word="car"] within europarl5_de: [word="Auto"]\n    ```\n\n    Use containing to find the whole structure and to display the whole structure as the result (KWIC).\n    This will find all paragraphs containing an acronym, i.e. a word consisting of 3 or more upper-case characters:\n    CQL:\n    ```cql\n    <p/> containing [word="[A-Z]{3,}"]\n    ```\n    This query searches for noun phrases (sequences of up to 5 adjectives followed by a noun) that contain the adjective international:\n    ```cql\n    [tag="J.*"]{1,5} [tag="N.*"] containing [word="international"]\n    ```\n\n    Use ! for negation:\n    !within = not within\n    !containing = not containing\n\n    This CQL will find all nouns that appear outside the <nphr> structure, i.e., outside noun phrases. The CQL will only work in corpora where the <nphr> structure exists:\n    CQL:\n    ```cql\n    [tag="N.*"]   !within   <nphr/>\n    ```\n    This CQL will find all sentences that do not contain any word starting with a capital letter:\n    CQL:\n    ```cql\n    <s/>   !containing   [word="[A-Z][A-Za-z]*"]\n    ```\n\n    Simultaneously searching the left and right context is only possible with meet and union operators. This is useful when a user wants to search for a token that is around or in the area of some other token.\n    Use meet to set the left and right context. This will find all nouns that have the verb to be 3 tokens to the left or 3 tokens to the right:\n    CQL:\n    ```cql\n    (meet [tag = "N.*"] [tag = "VB.*"] -3 3)\n    ```\n    Use the operator union to collect the results of two meet queries and display them in one concordance.\n    This CQL will, find all nouns with the verb to be at a distance of 3 tokens to the left or right, then find all adjectives with the verb to be at a distance of 2 tokens to the left or right, combine the nouns from the first query and adjectives from the second query and display them together in one concordance, the nouns and adjectives will be highlighted in the centre as KWIC:\n    CQL:\n    ```cql\n    (union (meet [tag="N.*"] [tag="VB.*"] -3 3) (meet [tag="A.*"] [tag="VB.*"] -2 2))\n    ```\n    This combines instances of nouns preceded by competent with adjectives followed by competence:\n    CQL:\n    ```cql\n    (union(meet [tag="N.*"] [lemma="competent"] -2 -1)(meet [tag="J.*"] [lemma="competence"]  1 2))\n    ```\n    Note that each meet and union has to be inside its own pair of brackets. Operators meet, and a union cannot be used with operators within and containing.\n\n    CQL also supports word sketch. Word sketches provide collocations for a word. The syntax is as follows:\n    CQL:\n    ```cql\n    [ws(headword, relation, collocation)]\n    ```\n    The relation is the name of the relation. You can often guess the name by using a regular expression like this:\n    CQL:\n    ```cql\n    [ws(headword, ".*subject.*", collocation)]\n    ```\n    For the exact name of the relation, the "%w" must be exchanged for \\"%w\\" as the quotes need to be backslashed in CQL. For example, the Word Sketch relation modifiers of "book" can be written as a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", "modifiers of \\"%w\\"", ".*")]\n    ```\n    Remember that Word Sketches are generated from lempos, so using a hyphen and the shortened PoS tag is necessary. For example, to generate a concordance with test (as a noun) being the object of conduct (as a verb), use this:\n    CQL:\n    ```cql\n    [ws("test-n",".*object.*","conduct-v")]\n    ```\n    In the resulting concordance, the headword is taken for a KWIC, and the collocations are used as a filter. It is possible to specify the headword by using the regular expression AND inside the square brackets. For example, to search for all relations of lempos "book-n" where the word appears in the plural form, you can use a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", ".*", ".*") & tag="NNS"]\n    ```\n    The prepositional phrases can be searched by the following syntax:\n    CQL:\n    ```cql\n    [ws("headword", "\\.\\.\\. [^ /]+ \\"%w\\"", ".*") | ws("headword", "\\"%w\\" [^ /]+ \\.\\.\\.", ".*")]\n    ```\n    In case only specific prepositions should be displayed, it is possible to insert them instead of [^ /]. This example will find concordance lines with the headword ‘test’ as a noun and prepositions of, in, or at:\n    CQL:\n    ```cql\n    [ws("test-n", "\\.\\.\\. (of|in|at) \\"%w\\"", ".*") | ws("test-n", "\\"%w\\" (of|in|at) \\.\\.\\.", ".*")]\n    ```\n    The Word Sketch CQL can be combined with other CQL markers. To generate a concordance where the headword test is modified by blood and followed or preceded by the lemma be, use this:\n    CQL:\n    ```cql\n    (meet [ws("test-n",".*modifiers of.*","blood-n")] [lemma="be"] -1 1)\n    ```\n\n    Thesaurus is also supported in CQL. Use the tilde ~ to generate a thesaurus (words with similar context, synonyms, antonyms) for the word and include the top N thesaurus items into the query. For example, to find the verb chop followed by vegetables, use this (or replace carrot with any other vegetable):\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~"carrot-n"\n    ```\n    To set the number of thesaurus items manually, use:\n    CQL:\n    ```cql\n    ~15"carrot-n"\n    ```\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~15"carrot-n"\n    ```\n    Thesaurus may be used with meet keyword, for example, to find all metals around the lemma corrosion:\n    CQL:\n    ```cql\n    (meet ~"metal-n" [lemma="corrosion"] -5 5)\n    ```\n\n    It is possible to add aditional constraints called global conditions.\n    You may use \'<number>:\' to specify a tag and then after whole CQL put & and write a global constraint. Only numbers may be used. For example:\n\n    Repetition of the same token:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word\n    ```\n    Repetition of the same token but different tag:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word & 1.tag != 2.tag\n    ```\n    Token with frequency higher than 2000\n    CQL:\n    ```cql\n    1:[] & f(1.word)>2000\n    ```\n\nYou are an expert assistant for Sketch Engine\'s Corpus Query Language (CQL).\nYour job is to read the conversation and translate the user\'s *latest* request into a single CQL query.\n\nImportant CQL reminders:\n- A query is a sequence of tokens, each inside square brackets: [ ... ].\n- Use attributes like word, lemma, tag, lc, lempos, structure attributes, etc.\n- Use regular expressions only when necessary.\n- Prefer lemma="..." when the user asks for \'all forms\' of a word.\n- Follow corpus-specific tags, annotations, structures and grammatical relations.\n\nCorpus description for corpus \'preloaded/ententen21_tt31\':\nCorpus language: English  \n\nCore token structures (each token has a separate record):  \n- word : the surface form  \n- tag : TreeTagger POS tag (see tag table below)  \n- lempos : lemma plus POS suffix (e.g. “run‑v”)  \n- pos : same as tag (kept for compatibility)  \n- lemma : lemmatized form  \n- lempos_lc : lempos in lowercase  \n- lemma_lc : lemma in lowercase  \n- lc : word in lowercase  \n\nDocument‑level structures (one per text):  \n- doc – attributes: url, title, wiki_categories, urldomain, website, crawl_date, modified_date, tld, wiki_translations, modified_month, modified_year, topic, tld_expl, domain_distance, genre, src, crawl_year  \n- p – attribute: heading (section heading)  \n- s – sentence identifier  \n- g – generic grouping (no attributes)  \n\nAnnotations (regular‑expression shortcuts for the tag field):  \n- adjective : “J.*”  \n- adverb : “RB.?”  \n- conjunction : “CC”  \n- determiner : “DT”  \n- noun : “N.*”  \n- numeral : “CD”  \n- particle : “RP”  \n- preposition : “IN”  \n- pronoun : “PP.?”  \n- verb : “V.*”  \n\nLempos suffixes (used in the lempos and lempos_lc fields):  \n‑j adjective\u2003‑a adverb\u2003‑c conjunction\u2003‑n noun\u2003‑m numeral\u2003‑i preposition\u2003‑d pronoun\u2003‑v verb  \n\n---  \n\nTreeTagger POS tagset (Sketch Engine modifications)  \n\nTag\u2003Description\u2003Example  \nCC\u2003coordinating conjunction\u2003and  \nCD\u2003cardinal number\u20031, one  \nCDZ\u2003possessive numeral\u2003one’s  \nDT\u2003determiner\u2003the  \nEX\u2003existential “there”\u2003there  \nFW\u2003foreign word\u2003d’hoevre  \nIN\u2003preposition or subordinating conjunction\u2003in, of, like  \nIN/that\u2003that as subordinator\u2003that  \nJJ\u2003adjective\u2003green  \nJJR\u2003adjective comparative\u2003greener  \nJJS\u2003adjective superlative\u2003greenest  \nLS\u2003list marker\u20031)  \nMD\u2003modal verb\u2003could, will  \nNN\u2003noun singular or mass\u2003table  \nNNS\u2003noun plural\u2003tables  \nNNSZ\u2003possessive noun plural\u2003people’s  \nNNZ\u2003possessive noun singular\u2003year’s  \nNP\u2003proper noun singular\u2003John  \nNPS\u2003proper noun plural\u2003Vikings  \nNPSZ\u2003possessive proper noun plural\u2003Boys’  \nNPZ\u2003possessive proper noun singular\u2003Britain’s  \nPDT\u2003predeterminer\u2003both the boys  \nPP\u2003personal pronoun\u2003I, he, it  \nPPZ\u2003possessive pronoun\u2003my, his  \nRB\u2003adverb\u2003however, usually  \nRBR\u2003adverb comparative\u2003better  \nRBS\u2003adverb superlative\u2003best  \nRP\u2003particle\u2003up (in “give up”)  \nSENT\u2003sentence‑final punctuation\u2003. ! ?  \nSYM\u2003other symbols\u2003/ = *  \nTO\u2003infinitive marker\u2003to (only when infinitival)  \nUH\u2003interjection\u2003uhhuhhuhh  \nVB\u2003verb “be”, base\u2003be  \nVBD\u2003verb “be”, past\u2003was, were  \nVBG\u2003verb “be”, gerund\u2003being  \nVBN\u2003verb “be”, past participle\u2003been  \nVBP\u2003verb “be”, present non‑3rd\u2003am, are  \nVBZ\u2003verb “be”, 3rd‑person present\u2003is  \nVH\u2003verb “have”, base\u2003have  \nVHD\u2003verb “have”, past\u2003had  \nVHG\u2003verb “have”, gerund\u2003having  \nVHN\u2003verb “have”, past participle\u2003had  \nVHP\u2003verb “have”, present non‑3rd\u2003have  \nVHZ\u2003verb “have”, 3rd‑person present\u2003has  \nVV\u2003other verbs, base\u2003take  \nVVD\u2003other verbs, past\u2003took  \nVVG\u2003other verbs, gerund\u2003taking  \nVVN\u2003other verbs, past participle\u2003taken  \nVVP\u2003other verbs, present non‑3rd\u2003take  \nVVZ\u2003other verbs, 3rd‑person present\u2003takes  \nWDT\u2003wh‑determiner\u2003which  \nWP\u2003wh‑pronoun\u2003who, what  \nWPZ\u2003possessive wh‑pronoun\u2003whose  \nWRB\u2003wh‑adverb\u2003where, when  \nZ\u2003possessive ending\u2003’s  \n\nKey differences from the Penn Treebank:  \n- “be” uses VB/VBD/VBG/VBN/VBP/VBZ, “have” uses VH/VHD/VHG/VHN/VHP/VHZ, all other verbs use VV series.  \n- Proper nouns are NP/NPS (instead of NNP/NNPS).  \n- SENT marks sentence‑final punctuation.  \n- Token “to” is tagged IN when a preposition, TO only when infinitival.  \n- Indefinite articles “a”/“an” are both lemmatized as “a”.  \n\nWord‑sketch (grammatical relation) patterns (use “%w” as the target word placeholder). Typical relation names that can be queried in CQL include:  \n\n%w is a …\u2003%w’s …\u2003… is a %w\u2003adjective predicates of %w\u2003adjectives after %w\u2003adjectives modified by %w\u2003adverbs modified by %w\u2003as reflexive\u2003complements of %w\u2003in passive\u2003infinitive objects of %w\u2003it’s %w to …\u2003modifiers of %w\u2003nouns modified by %w\u2003objects of %w\u2003objects of %w across/along/apart/around/aside/away/down/in/off/on/open/out/over/through/unto/up/upon/whole\u2003particles after %w (with object)\u2003possessors of %w\u2003prepositional phrases\u2003pronominal objects/possessors/subjects of %w\u2003subjects of %w\u2003subjects of “be %w”\u2003verbs before %w\u2003verbs complemented by %w\u2003verbs modified by %w\u2003verbs with %w as object\u2003verbs with %w as subject\u2003verbs with particle “across/along/…/upon” and %w as object\u2003wh‑words following %w  \n\nThese relation names correspond to the default word‑sketch grammar; they can be used in CQL with the syntax `[word="target"] [relation="relation_name"]` or via the built‑in shortcuts `[%w]` in the Sketch Engine UI.  \n\nDocument‑level filtering can be done on any doc attribute, e.g. `[doc.genre="news"]`, `[doc.crawl_year="2023"]`, `[doc.tld="com"]`.  \n\nAll structures and attributes are case‑sensitive; use straight double quotes in CQL expressions.\n\nOutput format requirements (very important):\n1. Respond with EXACTLY one fenced code block.\n2. The fence must be in this format:\n```cql\n[your CQL query here]\n```\n3. Do output any text before the code block. Use this for reasoning.\n4. Do explain the query, comment on it, or paraphrase the user. Before the code block.\n5. Do not ask for clarification. Respond directly.\n'}]}, {'role': 'user', 'content': [{'type': 'text', 'text': 'Najdi věty, které obsahují číslo větší než 100.'}]}]
{"detail":"Use of API key is not enabled in the environment."}
[{'role': 'system', 'content': [{'type': 'text', 'text': 'Definition of Corpus Query Language (CQL)\n    The CQL is a query language used in Sketch Engine for searching grammatical and lexical patterns. CQL sets criteria for positions and tokens, such as tag, word, lemma, lempos, etc.\n    Basic syntax is [attribute="value"], for example:\n    To find the lemma teapot, use\n    CQL:\n    ```cql\n    [lemma="teapot"]\n    ```\n    Each token must be inside its own pair of square brackets. To search for the phrase refill the teapot, use\n    CQL:\n    ```cql\n    [lemma="refill"][lemma="the"][lemma="teapot"]\n    ```\n    More examples:\n    find examples of went -> CQL:\n    ```cql\n    [word="went"]\n    ```\n    find examples of all forms of go -> CQL:\n    ```cql\n    [lemma="go"]\n    ```\n    find examples of all words tagged with the tag NP -> CQL:\n    ```cql\n    [tag="NP"]\n    ```\n\n    Regular expressions can be used with values in CQL. A complete set of Regular expressions is supported, and complex criteria can be used, for example:\n    words starting with confus- -> CQL:\n    ```cql\n    [lemma="confus.*"]\n    ```\n    words ending with -ious -> CQL:\n    ```cql\n    [lemma=".*ious"]\n    ```\n    three-letter words starting b- and ending -g -> CQL:\n    ```cql\n    [lemma="b.g"]\n    ```\n    Be aware that when searching for any of the characters [][.*+{}?()|\\\\"$^] literally, they must be escaped using a backslash in any context where you may used regular expressions.\n\n    Square brackets [ ] stand for "any token". Curly brackets { } are used for repetition of the preceding token, for example:\n    find examples of ‘refill’ and ‘kettle’ with one word in between -> CQL:\n    ```cql\n    [lemma="refill"] [ ] [lemma="kettle"]\n    ```\n    examples of ‘have’ and ‘opinion’ with 2 to 4 words in between -> CQL:\n    ```cql\n    [lemma="have"] [ ]{2,4}[lemma="opinion"]\n    ```\n    find examples of "drink" and "water" with exactly two adjectives between them -> CQL:\n    ```cql\n    [lemma="drink"] [tag="J.*"]{2}[lemma="water"]\n    ```\n\n    A token can be made optional by placing a question mark ? after the square bracket. For example:\n    Find examples of ‘drive my car’ or ‘drive my own car’ -> CQL:\n    ```cql\n    [lemma="drive"] [lc="my"] [lc="own"]? [lemma="car"]\n    ```\n    alternative solution without using ? -> CQL:\n    ```cql\n    [lemma="drive"][lc="my"][lc="own"]{0,1} [lemma="car"]\n    ```\n\n    These comparison operators are supported:\n    equal =\n    less than or equal to <=\n    more than or equal to >=\n    not equal !=\n    not less than or equal to !<=\n    not more than or equal to !>=\n    equal (no regex) ==\n    not equal (no regex) !==\n    The alphabetical parts of the value are compared lexicographically (‘in the dictionary order’) and numerical parts numerically. This is useful with structure attributes, where >="AB2010CD" will include values such as "BB0000CD", "AB2011CD" or "AB2010CE". Example:\n    all one-letter words -> CQL:\n    ```cql\n    [word="."]\n    ```\n    all full stops -> CQL:\n    ```cql\n    [word=="."]\n    ```\n\n    One token can have more conditions. They must all appear inside the same pair of square brackets, and Boolean operators must be used between them.\n    & (ampersand) = AND\n    | (pipe) = OR\n    ! (exclamation mark) = NOT\n    For example:\n    Find all forms of the word ‘test’ which is a noun -> CQL:\n    ```cql\n    [ lemma="test" & tag="N.*" ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & tag!="V.*"]\n    ```\n    finds the word round tagged as a noun or verb -> CQL:\n    ```cql\n    [ word="round" & ( tag="N.*" | tag="V.*" ) ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & !tag="V.*"]\n    ```\n\n    | (pipe) = OR - means one token or another token, i.e., the token to the right or left of the pipe.\n    This use of the pipe (|) should only be limited to cases with no other solution because it consumes the search time. In most cases, it can be replaced by a pipe used inside the token, which is faster. See examples below.\n    "big dog" or "wolf" -> CQL:\n    ```cql\n    ([lemma="big"][lemma="dog"]) | [lemma="wolf"]\n    ```\n\n    Structures refer to sentences, paragraphs, documents, or any other parts or sections into which a corpus might be divided. Another way of saying this is that certain parts of a corpus can be labelled, e.g., direct speech might be labelled using structures to make it possible to limit the search to only direct speech. Structures may or may not have values. Values are used to categorize instances of the same structure.\n    Structures can be referred to in three ways:\n    The beginning: <s> <p> <doc> etc.\n    The end: </s> </p> </doc> etc.\n    The whole structure: <s/> <p/> <doc/> etc.\n    For example:\n    Find all documents written in informal style that start with the word Rebecca -> CQL:\n    ```cql\n    <doc style="informal">[lemma="Rebecca"]\n    ```\n    find all documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    Written documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011" & type="written"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    find all verbs written in informal style -> CQL:\n    ```cql\n    [tag="V.*"]  within <doc style="informal" />\n    ```\n\n    The "containing" and "within" CQL operators are used to restrict the search only to a certain structure, e.g., to search inside:\n    Corpus structure, e.g., sentence, paragraph, document, etc.\n    Grammatical or lexical structure, e.g., noun phrase.\n\n    Use within to ensure the search result appears within the structure you want, in this case, within the same sentence, paragraph, document, or any other structure found in the corpus:\n    CQL:\n    ```cql\n    [word="dog"] []{0,5} [word="runs"] within < s/>\n    ```\n    The structure after "within" can be another CQL code defining a grammatical or lexical structure:\n    CQL:\n    ```cql\n    [tag="N.*"] within [tag="VB.*"] []{0,5} [tag="VB.*"]\n    ```\n    Multiple within operators can be nested if necessary:\n    CQL:\n    ```cql\n    [tag="N.*"] within ([tag="VB.*"] []{0,5} [tag="VB.*"] within < s/>)\n    ```\n    Use within to search a parallel corpus using this syntax:\n    within :\n    For example, with the English Europarl open, you can use this CQL to query the German Europarl. It will find all segments where the English corpus contains car and the aligned German segment contains Auto. In most cases, these will be segments where car was translated as Auto:\n    CQL:\n    ```cql\n    [word="car"] within europarl5_de: [word="Auto"]\n    ```\n\n    Use containing to find the whole structure and to display the whole structure as the result (KWIC).\n    This will find all paragraphs containing an acronym, i.e. a word consisting of 3 or more upper-case characters:\n    CQL:\n    ```cql\n    <p/> containing [word="[A-Z]{3,}"]\n    ```\n    This query searches for noun phrases (sequences of up to 5 adjectives followed by a noun) that contain the adjective international:\n    ```cql\n    [tag="J.*"]{1,5} [tag="N.*"] containing [word="international"]\n    ```\n\n    Use ! for negation:\n    !within = not within\n    !containing = not containing\n\n    This CQL will find all nouns that appear outside the <nphr> structure, i.e., outside noun phrases. The CQL will only work in corpora where the <nphr> structure exists:\n    CQL:\n    ```cql\n    [tag="N.*"]   !within   <nphr/>\n    ```\n    This CQL will find all sentences that do not contain any word starting with a capital letter:\n    CQL:\n    ```cql\n    <s/>   !containing   [word="[A-Z][A-Za-z]*"]\n    ```\n\n    Simultaneously searching the left and right context is only possible with meet and union operators. This is useful when a user wants to search for a token that is around or in the area of some other token.\n    Use meet to set the left and right context. This will find all nouns that have the verb to be 3 tokens to the left or 3 tokens to the right:\n    CQL:\n    ```cql\n    (meet [tag = "N.*"] [tag = "VB.*"] -3 3)\n    ```\n    Use the operator union to collect the results of two meet queries and display them in one concordance.\n    This CQL will, find all nouns with the verb to be at a distance of 3 tokens to the left or right, then find all adjectives with the verb to be at a distance of 2 tokens to the left or right, combine the nouns from the first query and adjectives from the second query and display them together in one concordance, the nouns and adjectives will be highlighted in the centre as KWIC:\n    CQL:\n    ```cql\n    (union (meet [tag="N.*"] [tag="VB.*"] -3 3) (meet [tag="A.*"] [tag="VB.*"] -2 2))\n    ```\n    This combines instances of nouns preceded by competent with adjectives followed by competence:\n    CQL:\n    ```cql\n    (union(meet [tag="N.*"] [lemma="competent"] -2 -1)(meet [tag="J.*"] [lemma="competence"]  1 2))\n    ```\n    Note that each meet and union has to be inside its own pair of brackets. Operators meet, and a union cannot be used with operators within and containing.\n\n    CQL also supports word sketch. Word sketches provide collocations for a word. The syntax is as follows:\n    CQL:\n    ```cql\n    [ws(headword, relation, collocation)]\n    ```\n    The relation is the name of the relation. You can often guess the name by using a regular expression like this:\n    CQL:\n    ```cql\n    [ws(headword, ".*subject.*", collocation)]\n    ```\n    For the exact name of the relation, the "%w" must be exchanged for \\"%w\\" as the quotes need to be backslashed in CQL. For example, the Word Sketch relation modifiers of "book" can be written as a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", "modifiers of \\"%w\\"", ".*")]\n    ```\n    Remember that Word Sketches are generated from lempos, so using a hyphen and the shortened PoS tag is necessary. For example, to generate a concordance with test (as a noun) being the object of conduct (as a verb), use this:\n    CQL:\n    ```cql\n    [ws("test-n",".*object.*","conduct-v")]\n    ```\n    In the resulting concordance, the headword is taken for a KWIC, and the collocations are used as a filter. It is possible to specify the headword by using the regular expression AND inside the square brackets. For example, to search for all relations of lempos "book-n" where the word appears in the plural form, you can use a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", ".*", ".*") & tag="NNS"]\n    ```\n    The prepositional phrases can be searched by the following syntax:\n    CQL:\n    ```cql\n    [ws("headword", "\\.\\.\\. [^ /]+ \\"%w\\"", ".*") | ws("headword", "\\"%w\\" [^ /]+ \\.\\.\\.", ".*")]\n    ```\n    In case only specific prepositions should be displayed, it is possible to insert them instead of [^ /]. This example will find concordance lines with the headword ‘test’ as a noun and prepositions of, in, or at:\n    CQL:\n    ```cql\n    [ws("test-n", "\\.\\.\\. (of|in|at) \\"%w\\"", ".*") | ws("test-n", "\\"%w\\" (of|in|at) \\.\\.\\.", ".*")]\n    ```\n    The Word Sketch CQL can be combined with other CQL markers. To generate a concordance where the headword test is modified by blood and followed or preceded by the lemma be, use this:\n    CQL:\n    ```cql\n    (meet [ws("test-n",".*modifiers of.*","blood-n")] [lemma="be"] -1 1)\n    ```\n\n    Thesaurus is also supported in CQL. Use the tilde ~ to generate a thesaurus (words with similar context, synonyms, antonyms) for the word and include the top N thesaurus items into the query. For example, to find the verb chop followed by vegetables, use this (or replace carrot with any other vegetable):\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~"carrot-n"\n    ```\n    To set the number of thesaurus items manually, use:\n    CQL:\n    ```cql\n    ~15"carrot-n"\n    ```\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~15"carrot-n"\n    ```\n    Thesaurus may be used with meet keyword, for example, to find all metals around the lemma corrosion:\n    CQL:\n    ```cql\n    (meet ~"metal-n" [lemma="corrosion"] -5 5)\n    ```\n\n    It is possible to add aditional constraints called global conditions.\n    You may use \'<number>:\' to specify a tag and then after whole CQL put & and write a global constraint. Only numbers may be used. For example:\n\n    Repetition of the same token:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word\n    ```\n    Repetition of the same token but different tag:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word & 1.tag != 2.tag\n    ```\n    Token with frequency higher than 2000\n    CQL:\n    ```cql\n    1:[] & f(1.word)>2000\n    ```\n\nYou are an expert assistant for Sketch Engine\'s Corpus Query Language (CQL).\nYour job is to read the conversation and translate the user\'s *latest* request into a single CQL query.\n\nImportant CQL reminders:\n- A query is a sequence of tokens, each inside square brackets: [ ... ].\n- Use attributes like word, lemma, tag, lc, lempos, structure attributes, etc.\n- Use regular expressions only when necessary.\n- Prefer lemma="..." when the user asks for \'all forms\' of a word.\n- Follow corpus-specific tags, annotations, structures and grammatical relations.\n\nCorpus description for corpus \'preloaded/ententen21_tt31\':\nCorpus language: English  \n\nCore token structures (each token has a separate record):  \n- word : the surface form  \n- tag : TreeTagger POS tag (see tag table below)  \n- lempos : lemma plus POS suffix (e.g. “run‑v”)  \n- pos : same as tag (kept for compatibility)  \n- lemma : lemmatized form  \n- lempos_lc : lempos in lowercase  \n- lemma_lc : lemma in lowercase  \n- lc : word in lowercase  \n\nDocument‑level structures (one per text):  \n- doc – attributes: url, title, wiki_categories, urldomain, website, crawl_date, modified_date, tld, wiki_translations, modified_month, modified_year, topic, tld_expl, domain_distance, genre, src, crawl_year  \n- p – attribute: heading (section heading)  \n- s – sentence identifier  \n- g – generic grouping (no attributes)  \n\nAnnotations (regular‑expression shortcuts for the tag field):  \n- adjective : “J.*”  \n- adverb : “RB.?”  \n- conjunction : “CC”  \n- determiner : “DT”  \n- noun : “N.*”  \n- numeral : “CD”  \n- particle : “RP”  \n- preposition : “IN”  \n- pronoun : “PP.?”  \n- verb : “V.*”  \n\nLempos suffixes (used in the lempos and lempos_lc fields):  \n‑j adjective\u2003‑a adverb\u2003‑c conjunction\u2003‑n noun\u2003‑m numeral\u2003‑i preposition\u2003‑d pronoun\u2003‑v verb  \n\n---  \n\nTreeTagger POS tagset (Sketch Engine modifications)  \n\nTag\u2003Description\u2003Example  \nCC\u2003coordinating conjunction\u2003and  \nCD\u2003cardinal number\u20031, one  \nCDZ\u2003possessive numeral\u2003one’s  \nDT\u2003determiner\u2003the  \nEX\u2003existential “there”\u2003there  \nFW\u2003foreign word\u2003d’hoevre  \nIN\u2003preposition or subordinating conjunction\u2003in, of, like  \nIN/that\u2003that as subordinator\u2003that  \nJJ\u2003adjective\u2003green  \nJJR\u2003adjective comparative\u2003greener  \nJJS\u2003adjective superlative\u2003greenest  \nLS\u2003list marker\u20031)  \nMD\u2003modal verb\u2003could, will  \nNN\u2003noun singular or mass\u2003table  \nNNS\u2003noun plural\u2003tables  \nNNSZ\u2003possessive noun plural\u2003people’s  \nNNZ\u2003possessive noun singular\u2003year’s  \nNP\u2003proper noun singular\u2003John  \nNPS\u2003proper noun plural\u2003Vikings  \nNPSZ\u2003possessive proper noun plural\u2003Boys’  \nNPZ\u2003possessive proper noun singular\u2003Britain’s  \nPDT\u2003predeterminer\u2003both the boys  \nPP\u2003personal pronoun\u2003I, he, it  \nPPZ\u2003possessive pronoun\u2003my, his  \nRB\u2003adverb\u2003however, usually  \nRBR\u2003adverb comparative\u2003better  \nRBS\u2003adverb superlative\u2003best  \nRP\u2003particle\u2003up (in “give up”)  \nSENT\u2003sentence‑final punctuation\u2003. ! ?  \nSYM\u2003other symbols\u2003/ = *  \nTO\u2003infinitive marker\u2003to (only when infinitival)  \nUH\u2003interjection\u2003uhhuhhuhh  \nVB\u2003verb “be”, base\u2003be  \nVBD\u2003verb “be”, past\u2003was, were  \nVBG\u2003verb “be”, gerund\u2003being  \nVBN\u2003verb “be”, past participle\u2003been  \nVBP\u2003verb “be”, present non‑3rd\u2003am, are  \nVBZ\u2003verb “be”, 3rd‑person present\u2003is  \nVH\u2003verb “have”, base\u2003have  \nVHD\u2003verb “have”, past\u2003had  \nVHG\u2003verb “have”, gerund\u2003having  \nVHN\u2003verb “have”, past participle\u2003had  \nVHP\u2003verb “have”, present non‑3rd\u2003have  \nVHZ\u2003verb “have”, 3rd‑person present\u2003has  \nVV\u2003other verbs, base\u2003take  \nVVD\u2003other verbs, past\u2003took  \nVVG\u2003other verbs, gerund\u2003taking  \nVVN\u2003other verbs, past participle\u2003taken  \nVVP\u2003other verbs, present non‑3rd\u2003take  \nVVZ\u2003other verbs, 3rd‑person present\u2003takes  \nWDT\u2003wh‑determiner\u2003which  \nWP\u2003wh‑pronoun\u2003who, what  \nWPZ\u2003possessive wh‑pronoun\u2003whose  \nWRB\u2003wh‑adverb\u2003where, when  \nZ\u2003possessive ending\u2003’s  \n\nKey differences from the Penn Treebank:  \n- “be” uses VB/VBD/VBG/VBN/VBP/VBZ, “have” uses VH/VHD/VHG/VHN/VHP/VHZ, all other verbs use VV series.  \n- Proper nouns are NP/NPS (instead of NNP/NNPS).  \n- SENT marks sentence‑final punctuation.  \n- Token “to” is tagged IN when a preposition, TO only when infinitival.  \n- Indefinite articles “a”/“an” are both lemmatized as “a”.  \n\nWord‑sketch (grammatical relation) patterns (use “%w” as the target word placeholder). Typical relation names that can be queried in CQL include:  \n\n%w is a …\u2003%w’s …\u2003… is a %w\u2003adjective predicates of %w\u2003adjectives after %w\u2003adjectives modified by %w\u2003adverbs modified by %w\u2003as reflexive\u2003complements of %w\u2003in passive\u2003infinitive objects of %w\u2003it’s %w to …\u2003modifiers of %w\u2003nouns modified by %w\u2003objects of %w\u2003objects of %w across/along/apart/around/aside/away/down/in/off/on/open/out/over/through/unto/up/upon/whole\u2003particles after %w (with object)\u2003possessors of %w\u2003prepositional phrases\u2003pronominal objects/possessors/subjects of %w\u2003subjects of %w\u2003subjects of “be %w”\u2003verbs before %w\u2003verbs complemented by %w\u2003verbs modified by %w\u2003verbs with %w as object\u2003verbs with %w as subject\u2003verbs with particle “across/along/…/upon” and %w as object\u2003wh‑words following %w  \n\nThese relation names correspond to the default word‑sketch grammar; they can be used in CQL with the syntax `[word="target"] [relation="relation_name"]` or via the built‑in shortcuts `[%w]` in the Sketch Engine UI.  \n\nDocument‑level filtering can be done on any doc attribute, e.g. `[doc.genre="news"]`, `[doc.crawl_year="2023"]`, `[doc.tld="com"]`.  \n\nAll structures and attributes are case‑sensitive; use straight double quotes in CQL expressions.\n\nOutput format requirements (very important):\n1. Respond with EXACTLY one fenced code block.\n2. The fence must be in this format:\n```cql\n[your CQL query here]\n```\n3. Do output any text before the code block. Use this for reasoning.\n4. Do explain the query, comment on it, or paraphrase the user. Before the code block.\n5. Do not ask for clarification. Respond directly.\n'}]}, {'role': 'user', 'content': [{'type': 'text', 'text': 'Najdi věty, které obsahují číslo větší než 100.'}]}]
{"detail":"Use of API key is not enabled in the environment."}
[{'role': 'system', 'content': [{'type': 'text', 'text': 'Definition of Corpus Query Language (CQL)\n    The CQL is a query language used in Sketch Engine for searching grammatical and lexical patterns. CQL sets criteria for positions and tokens, such as tag, word, lemma, lempos, etc.\n    Basic syntax is [attribute="value"], for example:\n    To find the lemma teapot, use\n    CQL:\n    ```cql\n    [lemma="teapot"]\n    ```\n    Each token must be inside its own pair of square brackets. To search for the phrase refill the teapot, use\n    CQL:\n    ```cql\n    [lemma="refill"][lemma="the"][lemma="teapot"]\n    ```\n    More examples:\n    find examples of went -> CQL:\n    ```cql\n    [word="went"]\n    ```\n    find examples of all forms of go -> CQL:\n    ```cql\n    [lemma="go"]\n    ```\n    find examples of all words tagged with the tag NP -> CQL:\n    ```cql\n    [tag="NP"]\n    ```\n\n    Regular expressions can be used with values in CQL. A complete set of Regular expressions is supported, and complex criteria can be used, for example:\n    words starting with confus- -> CQL:\n    ```cql\n    [lemma="confus.*"]\n    ```\n    words ending with -ious -> CQL:\n    ```cql\n    [lemma=".*ious"]\n    ```\n    three-letter words starting b- and ending -g -> CQL:\n    ```cql\n    [lemma="b.g"]\n    ```\n    Be aware that when searching for any of the characters [][.*+{}?()|\\\\"$^] literally, they must be escaped using a backslash in any context where you may used regular expressions.\n\n    Square brackets [ ] stand for "any token". Curly brackets { } are used for repetition of the preceding token, for example:\n    find examples of ‘refill’ and ‘kettle’ with one word in between -> CQL:\n    ```cql\n    [lemma="refill"] [ ] [lemma="kettle"]\n    ```\n    examples of ‘have’ and ‘opinion’ with 2 to 4 words in between -> CQL:\n    ```cql\n    [lemma="have"] [ ]{2,4}[lemma="opinion"]\n    ```\n    find examples of "drink" and "water" with exactly two adjectives between them -> CQL:\n    ```cql\n    [lemma="drink"] [tag="J.*"]{2}[lemma="water"]\n    ```\n\n    A token can be made optional by placing a question mark ? after the square bracket. For example:\n    Find examples of ‘drive my car’ or ‘drive my own car’ -> CQL:\n    ```cql\n    [lemma="drive"] [lc="my"] [lc="own"]? [lemma="car"]\n    ```\n    alternative solution without using ? -> CQL:\n    ```cql\n    [lemma="drive"][lc="my"][lc="own"]{0,1} [lemma="car"]\n    ```\n\n    These comparison operators are supported:\n    equal =\n    less than or equal to <=\n    more than or equal to >=\n    not equal !=\n    not less than or equal to !<=\n    not more than or equal to !>=\n    equal (no regex) ==\n    not equal (no regex) !==\n    The alphabetical parts of the value are compared lexicographically (‘in the dictionary order’) and numerical parts numerically. This is useful with structure attributes, where >="AB2010CD" will include values such as "BB0000CD", "AB2011CD" or "AB2010CE". Example:\n    all one-letter words -> CQL:\n    ```cql\n    [word="."]\n    ```\n    all full stops -> CQL:\n    ```cql\n    [word=="."]\n    ```\n\n    One token can have more conditions. They must all appear inside the same pair of square brackets, and Boolean operators must be used between them.\n    & (ampersand) = AND\n    | (pipe) = OR\n    ! (exclamation mark) = NOT\n    For example:\n    Find all forms of the word ‘test’ which is a noun -> CQL:\n    ```cql\n    [ lemma="test" & tag="N.*" ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & tag!="V.*"]\n    ```\n    finds the word round tagged as a noun or verb -> CQL:\n    ```cql\n    [ word="round" & ( tag="N.*" | tag="V.*" ) ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & !tag="V.*"]\n    ```\n\n    | (pipe) = OR - means one token or another token, i.e., the token to the right or left of the pipe.\n    This use of the pipe (|) should only be limited to cases with no other solution because it consumes the search time. In most cases, it can be replaced by a pipe used inside the token, which is faster. See examples below.\n    "big dog" or "wolf" -> CQL:\n    ```cql\n    ([lemma="big"][lemma="dog"]) | [lemma="wolf"]\n    ```\n\n    Structures refer to sentences, paragraphs, documents, or any other parts or sections into which a corpus might be divided. Another way of saying this is that certain parts of a corpus can be labelled, e.g., direct speech might be labelled using structures to make it possible to limit the search to only direct speech. Structures may or may not have values. Values are used to categorize instances of the same structure.\n    Structures can be referred to in three ways:\n    The beginning: <s> <p> <doc> etc.\n    The end: </s> </p> </doc> etc.\n    The whole structure: <s/> <p/> <doc/> etc.\n    For example:\n    Find all documents written in informal style that start with the word Rebecca -> CQL:\n    ```cql\n    <doc style="informal">[lemma="Rebecca"]\n    ```\n    find all documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    Written documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011" & type="written"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    find all verbs written in informal style -> CQL:\n    ```cql\n    [tag="V.*"]  within <doc style="informal" />\n    ```\n\n    The "containing" and "within" CQL operators are used to restrict the search only to a certain structure, e.g., to search inside:\n    Corpus structure, e.g., sentence, paragraph, document, etc.\n    Grammatical or lexical structure, e.g., noun phrase.\n\n    Use within to ensure the search result appears within the structure you want, in this case, within the same sentence, paragraph, document, or any other structure found in the corpus:\n    CQL:\n    ```cql\n    [word="dog"] []{0,5} [word="runs"] within < s/>\n    ```\n    The structure after "within" can be another CQL code defining a grammatical or lexical structure:\n    CQL:\n    ```cql\n    [tag="N.*"] within [tag="VB.*"] []{0,5} [tag="VB.*"]\n    ```\n    Multiple within operators can be nested if necessary:\n    CQL:\n    ```cql\n    [tag="N.*"] within ([tag="VB.*"] []{0,5} [tag="VB.*"] within < s/>)\n    ```\n    Use within to search a parallel corpus using this syntax:\n    within :\n    For example, with the English Europarl open, you can use this CQL to query the German Europarl. It will find all segments where the English corpus contains car and the aligned German segment contains Auto. In most cases, these will be segments where car was translated as Auto:\n    CQL:\n    ```cql\n    [word="car"] within europarl5_de: [word="Auto"]\n    ```\n\n    Use containing to find the whole structure and to display the whole structure as the result (KWIC).\n    This will find all paragraphs containing an acronym, i.e. a word consisting of 3 or more upper-case characters:\n    CQL:\n    ```cql\n    <p/> containing [word="[A-Z]{3,}"]\n    ```\n    This query searches for noun phrases (sequences of up to 5 adjectives followed by a noun) that contain the adjective international:\n    ```cql\n    [tag="J.*"]{1,5} [tag="N.*"] containing [word="international"]\n    ```\n\n    Use ! for negation:\n    !within = not within\n    !containing = not containing\n\n    This CQL will find all nouns that appear outside the <nphr> structure, i.e., outside noun phrases. The CQL will only work in corpora where the <nphr> structure exists:\n    CQL:\n    ```cql\n    [tag="N.*"]   !within   <nphr/>\n    ```\n    This CQL will find all sentences that do not contain any word starting with a capital letter:\n    CQL:\n    ```cql\n    <s/>   !containing   [word="[A-Z][A-Za-z]*"]\n    ```\n\n    Simultaneously searching the left and right context is only possible with meet and union operators. This is useful when a user wants to search for a token that is around or in the area of some other token.\n    Use meet to set the left and right context. This will find all nouns that have the verb to be 3 tokens to the left or 3 tokens to the right:\n    CQL:\n    ```cql\n    (meet [tag = "N.*"] [tag = "VB.*"] -3 3)\n    ```\n    Use the operator union to collect the results of two meet queries and display them in one concordance.\n    This CQL will, find all nouns with the verb to be at a distance of 3 tokens to the left or right, then find all adjectives with the verb to be at a distance of 2 tokens to the left or right, combine the nouns from the first query and adjectives from the second query and display them together in one concordance, the nouns and adjectives will be highlighted in the centre as KWIC:\n    CQL:\n    ```cql\n    (union (meet [tag="N.*"] [tag="VB.*"] -3 3) (meet [tag="A.*"] [tag="VB.*"] -2 2))\n    ```\n    This combines instances of nouns preceded by competent with adjectives followed by competence:\n    CQL:\n    ```cql\n    (union(meet [tag="N.*"] [lemma="competent"] -2 -1)(meet [tag="J.*"] [lemma="competence"]  1 2))\n    ```\n    Note that each meet and union has to be inside its own pair of brackets. Operators meet, and a union cannot be used with operators within and containing.\n\n    CQL also supports word sketch. Word sketches provide collocations for a word. The syntax is as follows:\n    CQL:\n    ```cql\n    [ws(headword, relation, collocation)]\n    ```\n    The relation is the name of the relation. You can often guess the name by using a regular expression like this:\n    CQL:\n    ```cql\n    [ws(headword, ".*subject.*", collocation)]\n    ```\n    For the exact name of the relation, the "%w" must be exchanged for \\"%w\\" as the quotes need to be backslashed in CQL. For example, the Word Sketch relation modifiers of "book" can be written as a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", "modifiers of \\"%w\\"", ".*")]\n    ```\n    Remember that Word Sketches are generated from lempos, so using a hyphen and the shortened PoS tag is necessary. For example, to generate a concordance with test (as a noun) being the object of conduct (as a verb), use this:\n    CQL:\n    ```cql\n    [ws("test-n",".*object.*","conduct-v")]\n    ```\n    In the resulting concordance, the headword is taken for a KWIC, and the collocations are used as a filter. It is possible to specify the headword by using the regular expression AND inside the square brackets. For example, to search for all relations of lempos "book-n" where the word appears in the plural form, you can use a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", ".*", ".*") & tag="NNS"]\n    ```\n    The prepositional phrases can be searched by the following syntax:\n    CQL:\n    ```cql\n    [ws("headword", "\\.\\.\\. [^ /]+ \\"%w\\"", ".*") | ws("headword", "\\"%w\\" [^ /]+ \\.\\.\\.", ".*")]\n    ```\n    In case only specific prepositions should be displayed, it is possible to insert them instead of [^ /]. This example will find concordance lines with the headword ‘test’ as a noun and prepositions of, in, or at:\n    CQL:\n    ```cql\n    [ws("test-n", "\\.\\.\\. (of|in|at) \\"%w\\"", ".*") | ws("test-n", "\\"%w\\" (of|in|at) \\.\\.\\.", ".*")]\n    ```\n    The Word Sketch CQL can be combined with other CQL markers. To generate a concordance where the headword test is modified by blood and followed or preceded by the lemma be, use this:\n    CQL:\n    ```cql\n    (meet [ws("test-n",".*modifiers of.*","blood-n")] [lemma="be"] -1 1)\n    ```\n\n    Thesaurus is also supported in CQL. Use the tilde ~ to generate a thesaurus (words with similar context, synonyms, antonyms) for the word and include the top N thesaurus items into the query. For example, to find the verb chop followed by vegetables, use this (or replace carrot with any other vegetable):\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~"carrot-n"\n    ```\n    To set the number of thesaurus items manually, use:\n    CQL:\n    ```cql\n    ~15"carrot-n"\n    ```\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~15"carrot-n"\n    ```\n    Thesaurus may be used with meet keyword, for example, to find all metals around the lemma corrosion:\n    CQL:\n    ```cql\n    (meet ~"metal-n" [lemma="corrosion"] -5 5)\n    ```\n\n    It is possible to add aditional constraints called global conditions.\n    You may use \'<number>:\' to specify a tag and then after whole CQL put & and write a global constraint. Only numbers may be used. For example:\n\n    Repetition of the same token:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word\n    ```\n    Repetition of the same token but different tag:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word & 1.tag != 2.tag\n    ```\n    Token with frequency higher than 2000\n    CQL:\n    ```cql\n    1:[] & f(1.word)>2000\n    ```\n\nYou are an expert assistant for Sketch Engine\'s Corpus Query Language (CQL).\nYour job is to read the conversation and translate the user\'s *latest* request into a single CQL query.\n\nImportant CQL reminders:\n- A query is a sequence of tokens, each inside square brackets: [ ... ].\n- Use attributes like word, lemma, tag, lc, lempos, structure attributes, etc.\n- Use regular expressions only when necessary.\n- Prefer lemma="..." when the user asks for \'all forms\' of a word.\n- Follow corpus-specific tags, annotations, structures and grammatical relations.\n\nCorpus description for corpus \'preloaded/ententen21_tt31\':\nCorpus language: English  \n\nCore token structures (each token has a separate record):  \n- word : the surface form  \n- tag : TreeTagger POS tag (see tag table below)  \n- lempos : lemma plus POS suffix (e.g. “run‑v”)  \n- pos : same as tag (kept for compatibility)  \n- lemma : lemmatized form  \n- lempos_lc : lempos in lowercase  \n- lemma_lc : lemma in lowercase  \n- lc : word in lowercase  \n\nDocument‑level structures (one per text):  \n- doc – attributes: url, title, wiki_categories, urldomain, website, crawl_date, modified_date, tld, wiki_translations, modified_month, modified_year, topic, tld_expl, domain_distance, genre, src, crawl_year  \n- p – attribute: heading (section heading)  \n- s – sentence identifier  \n- g – generic grouping (no attributes)  \n\nAnnotations (regular‑expression shortcuts for the tag field):  \n- adjective : “J.*”  \n- adverb : “RB.?”  \n- conjunction : “CC”  \n- determiner : “DT”  \n- noun : “N.*”  \n- numeral : “CD”  \n- particle : “RP”  \n- preposition : “IN”  \n- pronoun : “PP.?”  \n- verb : “V.*”  \n\nLempos suffixes (used in the lempos and lempos_lc fields):  \n‑j adjective\u2003‑a adverb\u2003‑c conjunction\u2003‑n noun\u2003‑m numeral\u2003‑i preposition\u2003‑d pronoun\u2003‑v verb  \n\n---  \n\nTreeTagger POS tagset (Sketch Engine modifications)  \n\nTag\u2003Description\u2003Example  \nCC\u2003coordinating conjunction\u2003and  \nCD\u2003cardinal number\u20031, one  \nCDZ\u2003possessive numeral\u2003one’s  \nDT\u2003determiner\u2003the  \nEX\u2003existential “there”\u2003there  \nFW\u2003foreign word\u2003d’hoevre  \nIN\u2003preposition or subordinating conjunction\u2003in, of, like  \nIN/that\u2003that as subordinator\u2003that  \nJJ\u2003adjective\u2003green  \nJJR\u2003adjective comparative\u2003greener  \nJJS\u2003adjective superlative\u2003greenest  \nLS\u2003list marker\u20031)  \nMD\u2003modal verb\u2003could, will  \nNN\u2003noun singular or mass\u2003table  \nNNS\u2003noun plural\u2003tables  \nNNSZ\u2003possessive noun plural\u2003people’s  \nNNZ\u2003possessive noun singular\u2003year’s  \nNP\u2003proper noun singular\u2003John  \nNPS\u2003proper noun plural\u2003Vikings  \nNPSZ\u2003possessive proper noun plural\u2003Boys’  \nNPZ\u2003possessive proper noun singular\u2003Britain’s  \nPDT\u2003predeterminer\u2003both the boys  \nPP\u2003personal pronoun\u2003I, he, it  \nPPZ\u2003possessive pronoun\u2003my, his  \nRB\u2003adverb\u2003however, usually  \nRBR\u2003adverb comparative\u2003better  \nRBS\u2003adverb superlative\u2003best  \nRP\u2003particle\u2003up (in “give up”)  \nSENT\u2003sentence‑final punctuation\u2003. ! ?  \nSYM\u2003other symbols\u2003/ = *  \nTO\u2003infinitive marker\u2003to (only when infinitival)  \nUH\u2003interjection\u2003uhhuhhuhh  \nVB\u2003verb “be”, base\u2003be  \nVBD\u2003verb “be”, past\u2003was, were  \nVBG\u2003verb “be”, gerund\u2003being  \nVBN\u2003verb “be”, past participle\u2003been  \nVBP\u2003verb “be”, present non‑3rd\u2003am, are  \nVBZ\u2003verb “be”, 3rd‑person present\u2003is  \nVH\u2003verb “have”, base\u2003have  \nVHD\u2003verb “have”, past\u2003had  \nVHG\u2003verb “have”, gerund\u2003having  \nVHN\u2003verb “have”, past participle\u2003had  \nVHP\u2003verb “have”, present non‑3rd\u2003have  \nVHZ\u2003verb “have”, 3rd‑person present\u2003has  \nVV\u2003other verbs, base\u2003take  \nVVD\u2003other verbs, past\u2003took  \nVVG\u2003other verbs, gerund\u2003taking  \nVVN\u2003other verbs, past participle\u2003taken  \nVVP\u2003other verbs, present non‑3rd\u2003take  \nVVZ\u2003other verbs, 3rd‑person present\u2003takes  \nWDT\u2003wh‑determiner\u2003which  \nWP\u2003wh‑pronoun\u2003who, what  \nWPZ\u2003possessive wh‑pronoun\u2003whose  \nWRB\u2003wh‑adverb\u2003where, when  \nZ\u2003possessive ending\u2003’s  \n\nKey differences from the Penn Treebank:  \n- “be” uses VB/VBD/VBG/VBN/VBP/VBZ, “have” uses VH/VHD/VHG/VHN/VHP/VHZ, all other verbs use VV series.  \n- Proper nouns are NP/NPS (instead of NNP/NNPS).  \n- SENT marks sentence‑final punctuation.  \n- Token “to” is tagged IN when a preposition, TO only when infinitival.  \n- Indefinite articles “a”/“an” are both lemmatized as “a”.  \n\nWord‑sketch (grammatical relation) patterns (use “%w” as the target word placeholder). Typical relation names that can be queried in CQL include:  \n\n%w is a …\u2003%w’s …\u2003… is a %w\u2003adjective predicates of %w\u2003adjectives after %w\u2003adjectives modified by %w\u2003adverbs modified by %w\u2003as reflexive\u2003complements of %w\u2003in passive\u2003infinitive objects of %w\u2003it’s %w to …\u2003modifiers of %w\u2003nouns modified by %w\u2003objects of %w\u2003objects of %w across/along/apart/around/aside/away/down/in/off/on/open/out/over/through/unto/up/upon/whole\u2003particles after %w (with object)\u2003possessors of %w\u2003prepositional phrases\u2003pronominal objects/possessors/subjects of %w\u2003subjects of %w\u2003subjects of “be %w”\u2003verbs before %w\u2003verbs complemented by %w\u2003verbs modified by %w\u2003verbs with %w as object\u2003verbs with %w as subject\u2003verbs with particle “across/along/…/upon” and %w as object\u2003wh‑words following %w  \n\nThese relation names correspond to the default word‑sketch grammar; they can be used in CQL with the syntax `[word="target"] [relation="relation_name"]` or via the built‑in shortcuts `[%w]` in the Sketch Engine UI.  \n\nDocument‑level filtering can be done on any doc attribute, e.g. `[doc.genre="news"]`, `[doc.crawl_year="2023"]`, `[doc.tld="com"]`.  \n\nAll structures and attributes are case‑sensitive; use straight double quotes in CQL expressions.\n\nOutput format requirements (very important):\n1. Respond with EXACTLY one fenced code block.\n2. The fence must be in this format:\n```cql\n[your CQL query here]\n```\n3. Do output any text before the code block. Use this for reasoning.\n4. Do explain the query, comment on it, or paraphrase the user. Before the code block.\n5. Do not ask for clarification. Respond directly.\n'}]}, {'role': 'user', 'content': [{'type': 'text', 'text': 'Najdi věty, které obsahují číslo větší než 100.'}]}]
{"detail":"Use of API key is not enabled in the environment."}
[{'role': 'system', 'content': [{'type': 'text', 'text': 'Definition of Corpus Query Language (CQL)\n    The CQL is a query language used in Sketch Engine for searching grammatical and lexical patterns. CQL sets criteria for positions and tokens, such as tag, word, lemma, lempos, etc.\n    Basic syntax is [attribute="value"], for example:\n    To find the lemma teapot, use\n    CQL:\n    ```cql\n    [lemma="teapot"]\n    ```\n    Each token must be inside its own pair of square brackets. To search for the phrase refill the teapot, use\n    CQL:\n    ```cql\n    [lemma="refill"][lemma="the"][lemma="teapot"]\n    ```\n    More examples:\n    find examples of went -> CQL:\n    ```cql\n    [word="went"]\n    ```\n    find examples of all forms of go -> CQL:\n    ```cql\n    [lemma="go"]\n    ```\n    find examples of all words tagged with the tag NP -> CQL:\n    ```cql\n    [tag="NP"]\n    ```\n\n    Regular expressions can be used with values in CQL. A complete set of Regular expressions is supported, and complex criteria can be used, for example:\n    words starting with confus- -> CQL:\n    ```cql\n    [lemma="confus.*"]\n    ```\n    words ending with -ious -> CQL:\n    ```cql\n    [lemma=".*ious"]\n    ```\n    three-letter words starting b- and ending -g -> CQL:\n    ```cql\n    [lemma="b.g"]\n    ```\n    Be aware that when searching for any of the characters [][.*+{}?()|\\\\"$^] literally, they must be escaped using a backslash in any context where you may used regular expressions.\n\n    Square brackets [ ] stand for "any token". Curly brackets { } are used for repetition of the preceding token, for example:\n    find examples of ‘refill’ and ‘kettle’ with one word in between -> CQL:\n    ```cql\n    [lemma="refill"] [ ] [lemma="kettle"]\n    ```\n    examples of ‘have’ and ‘opinion’ with 2 to 4 words in between -> CQL:\n    ```cql\n    [lemma="have"] [ ]{2,4}[lemma="opinion"]\n    ```\n    find examples of "drink" and "water" with exactly two adjectives between them -> CQL:\n    ```cql\n    [lemma="drink"] [tag="J.*"]{2}[lemma="water"]\n    ```\n\n    A token can be made optional by placing a question mark ? after the square bracket. For example:\n    Find examples of ‘drive my car’ or ‘drive my own car’ -> CQL:\n    ```cql\n    [lemma="drive"] [lc="my"] [lc="own"]? [lemma="car"]\n    ```\n    alternative solution without using ? -> CQL:\n    ```cql\n    [lemma="drive"][lc="my"][lc="own"]{0,1} [lemma="car"]\n    ```\n\n    These comparison operators are supported:\n    equal =\n    less than or equal to <=\n    more than or equal to >=\n    not equal !=\n    not less than or equal to !<=\n    not more than or equal to !>=\n    equal (no regex) ==\n    not equal (no regex) !==\n    The alphabetical parts of the value are compared lexicographically (‘in the dictionary order’) and numerical parts numerically. This is useful with structure attributes, where >="AB2010CD" will include values such as "BB0000CD", "AB2011CD" or "AB2010CE". Example:\n    all one-letter words -> CQL:\n    ```cql\n    [word="."]\n    ```\n    all full stops -> CQL:\n    ```cql\n    [word=="."]\n    ```\n\n    One token can have more conditions. They must all appear inside the same pair of square brackets, and Boolean operators must be used between them.\n    & (ampersand) = AND\n    | (pipe) = OR\n    ! (exclamation mark) = NOT\n    For example:\n    Find all forms of the word ‘test’ which is a noun -> CQL:\n    ```cql\n    [ lemma="test" & tag="N.*" ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & tag!="V.*"]\n    ```\n    finds the word round tagged as a noun or verb -> CQL:\n    ```cql\n    [ word="round" & ( tag="N.*" | tag="V.*" ) ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & !tag="V.*"]\n    ```\n\n    | (pipe) = OR - means one token or another token, i.e., the token to the right or left of the pipe.\n    This use of the pipe (|) should only be limited to cases with no other solution because it consumes the search time. In most cases, it can be replaced by a pipe used inside the token, which is faster. See examples below.\n    "big dog" or "wolf" -> CQL:\n    ```cql\n    ([lemma="big"][lemma="dog"]) | [lemma="wolf"]\n    ```\n\n    Structures refer to sentences, paragraphs, documents, or any other parts or sections into which a corpus might be divided. Another way of saying this is that certain parts of a corpus can be labelled, e.g., direct speech might be labelled using structures to make it possible to limit the search to only direct speech. Structures may or may not have values. Values are used to categorize instances of the same structure.\n    Structures can be referred to in three ways:\n    The beginning: <s> <p> <doc> etc.\n    The end: </s> </p> </doc> etc.\n    The whole structure: <s/> <p/> <doc/> etc.\n    For example:\n    Find all documents written in informal style that start with the word Rebecca -> CQL:\n    ```cql\n    <doc style="informal">[lemma="Rebecca"]\n    ```\n    find all documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    Written documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011" & type="written"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    find all verbs written in informal style -> CQL:\n    ```cql\n    [tag="V.*"]  within <doc style="informal" />\n    ```\n\n    The "containing" and "within" CQL operators are used to restrict the search only to a certain structure, e.g., to search inside:\n    Corpus structure, e.g., sentence, paragraph, document, etc.\n    Grammatical or lexical structure, e.g., noun phrase.\n\n    Use within to ensure the search result appears within the structure you want, in this case, within the same sentence, paragraph, document, or any other structure found in the corpus:\n    CQL:\n    ```cql\n    [word="dog"] []{0,5} [word="runs"] within < s/>\n    ```\n    The structure after "within" can be another CQL code defining a grammatical or lexical structure:\n    CQL:\n    ```cql\n    [tag="N.*"] within [tag="VB.*"] []{0,5} [tag="VB.*"]\n    ```\n    Multiple within operators can be nested if necessary:\n    CQL:\n    ```cql\n    [tag="N.*"] within ([tag="VB.*"] []{0,5} [tag="VB.*"] within < s/>)\n    ```\n    Use within to search a parallel corpus using this syntax:\n    within :\n    For example, with the English Europarl open, you can use this CQL to query the German Europarl. It will find all segments where the English corpus contains car and the aligned German segment contains Auto. In most cases, these will be segments where car was translated as Auto:\n    CQL:\n    ```cql\n    [word="car"] within europarl5_de: [word="Auto"]\n    ```\n\n    Use containing to find the whole structure and to display the whole structure as the result (KWIC).\n    This will find all paragraphs containing an acronym, i.e. a word consisting of 3 or more upper-case characters:\n    CQL:\n    ```cql\n    <p/> containing [word="[A-Z]{3,}"]\n    ```\n    This query searches for noun phrases (sequences of up to 5 adjectives followed by a noun) that contain the adjective international:\n    ```cql\n    [tag="J.*"]{1,5} [tag="N.*"] containing [word="international"]\n    ```\n\n    Use ! for negation:\n    !within = not within\n    !containing = not containing\n\n    This CQL will find all nouns that appear outside the <nphr> structure, i.e., outside noun phrases. The CQL will only work in corpora where the <nphr> structure exists:\n    CQL:\n    ```cql\n    [tag="N.*"]   !within   <nphr/>\n    ```\n    This CQL will find all sentences that do not contain any word starting with a capital letter:\n    CQL:\n    ```cql\n    <s/>   !containing   [word="[A-Z][A-Za-z]*"]\n    ```\n\n    Simultaneously searching the left and right context is only possible with meet and union operators. This is useful when a user wants to search for a token that is around or in the area of some other token.\n    Use meet to set the left and right context. This will find all nouns that have the verb to be 3 tokens to the left or 3 tokens to the right:\n    CQL:\n    ```cql\n    (meet [tag = "N.*"] [tag = "VB.*"] -3 3)\n    ```\n    Use the operator union to collect the results of two meet queries and display them in one concordance.\n    This CQL will, find all nouns with the verb to be at a distance of 3 tokens to the left or right, then find all adjectives with the verb to be at a distance of 2 tokens to the left or right, combine the nouns from the first query and adjectives from the second query and display them together in one concordance, the nouns and adjectives will be highlighted in the centre as KWIC:\n    CQL:\n    ```cql\n    (union (meet [tag="N.*"] [tag="VB.*"] -3 3) (meet [tag="A.*"] [tag="VB.*"] -2 2))\n    ```\n    This combines instances of nouns preceded by competent with adjectives followed by competence:\n    CQL:\n    ```cql\n    (union(meet [tag="N.*"] [lemma="competent"] -2 -1)(meet [tag="J.*"] [lemma="competence"]  1 2))\n    ```\n    Note that each meet and union has to be inside its own pair of brackets. Operators meet, and a union cannot be used with operators within and containing.\n\n    CQL also supports word sketch. Word sketches provide collocations for a word. The syntax is as follows:\n    CQL:\n    ```cql\n    [ws(headword, relation, collocation)]\n    ```\n    The relation is the name of the relation. You can often guess the name by using a regular expression like this:\n    CQL:\n    ```cql\n    [ws(headword, ".*subject.*", collocation)]\n    ```\n    For the exact name of the relation, the "%w" must be exchanged for \\"%w\\" as the quotes need to be backslashed in CQL. For example, the Word Sketch relation modifiers of "book" can be written as a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", "modifiers of \\"%w\\"", ".*")]\n    ```\n    Remember that Word Sketches are generated from lempos, so using a hyphen and the shortened PoS tag is necessary. For example, to generate a concordance with test (as a noun) being the object of conduct (as a verb), use this:\n    CQL:\n    ```cql\n    [ws("test-n",".*object.*","conduct-v")]\n    ```\n    In the resulting concordance, the headword is taken for a KWIC, and the collocations are used as a filter. It is possible to specify the headword by using the regular expression AND inside the square brackets. For example, to search for all relations of lempos "book-n" where the word appears in the plural form, you can use a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", ".*", ".*") & tag="NNS"]\n    ```\n    The prepositional phrases can be searched by the following syntax:\n    CQL:\n    ```cql\n    [ws("headword", "\\.\\.\\. [^ /]+ \\"%w\\"", ".*") | ws("headword", "\\"%w\\" [^ /]+ \\.\\.\\.", ".*")]\n    ```\n    In case only specific prepositions should be displayed, it is possible to insert them instead of [^ /]. This example will find concordance lines with the headword ‘test’ as a noun and prepositions of, in, or at:\n    CQL:\n    ```cql\n    [ws("test-n", "\\.\\.\\. (of|in|at) \\"%w\\"", ".*") | ws("test-n", "\\"%w\\" (of|in|at) \\.\\.\\.", ".*")]\n    ```\n    The Word Sketch CQL can be combined with other CQL markers. To generate a concordance where the headword test is modified by blood and followed or preceded by the lemma be, use this:\n    CQL:\n    ```cql\n    (meet [ws("test-n",".*modifiers of.*","blood-n")] [lemma="be"] -1 1)\n    ```\n\n    Thesaurus is also supported in CQL. Use the tilde ~ to generate a thesaurus (words with similar context, synonyms, antonyms) for the word and include the top N thesaurus items into the query. For example, to find the verb chop followed by vegetables, use this (or replace carrot with any other vegetable):\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~"carrot-n"\n    ```\n    To set the number of thesaurus items manually, use:\n    CQL:\n    ```cql\n    ~15"carrot-n"\n    ```\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~15"carrot-n"\n    ```\n    Thesaurus may be used with meet keyword, for example, to find all metals around the lemma corrosion:\n    CQL:\n    ```cql\n    (meet ~"metal-n" [lemma="corrosion"] -5 5)\n    ```\n\n    It is possible to add aditional constraints called global conditions.\n    You may use \'<number>:\' to specify a tag and then after whole CQL put & and write a global constraint. Only numbers may be used. For example:\n\n    Repetition of the same token:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word\n    ```\n    Repetition of the same token but different tag:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word & 1.tag != 2.tag\n    ```\n    Token with frequency higher than 2000\n    CQL:\n    ```cql\n    1:[] & f(1.word)>2000\n    ```\n\nYou are an expert assistant for Sketch Engine\'s Corpus Query Language (CQL).\nYour job is to read the conversation and translate the user\'s *latest* request into a single CQL query.\n\nImportant CQL reminders:\n- A query is a sequence of tokens, each inside square brackets: [ ... ].\n- Use attributes like word, lemma, tag, lc, lempos, structure attributes, etc.\n- Use regular expressions only when necessary.\n- Prefer lemma="..." when the user asks for \'all forms\' of a word.\n- Follow corpus-specific tags, annotations, structures and grammatical relations.\n\nCorpus description for corpus \'preloaded/ententen21_tt31\':\nCorpus language: English  \n\nCore token structures (each token has a separate record):  \n- word : the surface form  \n- tag : TreeTagger POS tag (see tag table below)  \n- lempos : lemma plus POS suffix (e.g. “run‑v”)  \n- pos : same as tag (kept for compatibility)  \n- lemma : lemmatized form  \n- lempos_lc : lempos in lowercase  \n- lemma_lc : lemma in lowercase  \n- lc : word in lowercase  \n\nDocument‑level structures (one per text):  \n- doc – attributes: url, title, wiki_categories, urldomain, website, crawl_date, modified_date, tld, wiki_translations, modified_month, modified_year, topic, tld_expl, domain_distance, genre, src, crawl_year  \n- p – attribute: heading (section heading)  \n- s – sentence identifier  \n- g – generic grouping (no attributes)  \n\nAnnotations (regular‑expression shortcuts for the tag field):  \n- adjective : “J.*”  \n- adverb : “RB.?”  \n- conjunction : “CC”  \n- determiner : “DT”  \n- noun : “N.*”  \n- numeral : “CD”  \n- particle : “RP”  \n- preposition : “IN”  \n- pronoun : “PP.?”  \n- verb : “V.*”  \n\nLempos suffixes (used in the lempos and lempos_lc fields):  \n‑j adjective\u2003‑a adverb\u2003‑c conjunction\u2003‑n noun\u2003‑m numeral\u2003‑i preposition\u2003‑d pronoun\u2003‑v verb  \n\n---  \n\nTreeTagger POS tagset (Sketch Engine modifications)  \n\nTag\u2003Description\u2003Example  \nCC\u2003coordinating conjunction\u2003and  \nCD\u2003cardinal number\u20031, one  \nCDZ\u2003possessive numeral\u2003one’s  \nDT\u2003determiner\u2003the  \nEX\u2003existential “there”\u2003there  \nFW\u2003foreign word\u2003d’hoevre  \nIN\u2003preposition or subordinating conjunction\u2003in, of, like  \nIN/that\u2003that as subordinator\u2003that  \nJJ\u2003adjective\u2003green  \nJJR\u2003adjective comparative\u2003greener  \nJJS\u2003adjective superlative\u2003greenest  \nLS\u2003list marker\u20031)  \nMD\u2003modal verb\u2003could, will  \nNN\u2003noun singular or mass\u2003table  \nNNS\u2003noun plural\u2003tables  \nNNSZ\u2003possessive noun plural\u2003people’s  \nNNZ\u2003possessive noun singular\u2003year’s  \nNP\u2003proper noun singular\u2003John  \nNPS\u2003proper noun plural\u2003Vikings  \nNPSZ\u2003possessive proper noun plural\u2003Boys’  \nNPZ\u2003possessive proper noun singular\u2003Britain’s  \nPDT\u2003predeterminer\u2003both the boys  \nPP\u2003personal pronoun\u2003I, he, it  \nPPZ\u2003possessive pronoun\u2003my, his  \nRB\u2003adverb\u2003however, usually  \nRBR\u2003adverb comparative\u2003better  \nRBS\u2003adverb superlative\u2003best  \nRP\u2003particle\u2003up (in “give up”)  \nSENT\u2003sentence‑final punctuation\u2003. ! ?  \nSYM\u2003other symbols\u2003/ = *  \nTO\u2003infinitive marker\u2003to (only when infinitival)  \nUH\u2003interjection\u2003uhhuhhuhh  \nVB\u2003verb “be”, base\u2003be  \nVBD\u2003verb “be”, past\u2003was, were  \nVBG\u2003verb “be”, gerund\u2003being  \nVBN\u2003verb “be”, past participle\u2003been  \nVBP\u2003verb “be”, present non‑3rd\u2003am, are  \nVBZ\u2003verb “be”, 3rd‑person present\u2003is  \nVH\u2003verb “have”, base\u2003have  \nVHD\u2003verb “have”, past\u2003had  \nVHG\u2003verb “have”, gerund\u2003having  \nVHN\u2003verb “have”, past participle\u2003had  \nVHP\u2003verb “have”, present non‑3rd\u2003have  \nVHZ\u2003verb “have”, 3rd‑person present\u2003has  \nVV\u2003other verbs, base\u2003take  \nVVD\u2003other verbs, past\u2003took  \nVVG\u2003other verbs, gerund\u2003taking  \nVVN\u2003other verbs, past participle\u2003taken  \nVVP\u2003other verbs, present non‑3rd\u2003take  \nVVZ\u2003other verbs, 3rd‑person present\u2003takes  \nWDT\u2003wh‑determiner\u2003which  \nWP\u2003wh‑pronoun\u2003who, what  \nWPZ\u2003possessive wh‑pronoun\u2003whose  \nWRB\u2003wh‑adverb\u2003where, when  \nZ\u2003possessive ending\u2003’s  \n\nKey differences from the Penn Treebank:  \n- “be” uses VB/VBD/VBG/VBN/VBP/VBZ, “have” uses VH/VHD/VHG/VHN/VHP/VHZ, all other verbs use VV series.  \n- Proper nouns are NP/NPS (instead of NNP/NNPS).  \n- SENT marks sentence‑final punctuation.  \n- Token “to” is tagged IN when a preposition, TO only when infinitival.  \n- Indefinite articles “a”/“an” are both lemmatized as “a”.  \n\nWord‑sketch (grammatical relation) patterns (use “%w” as the target word placeholder). Typical relation names that can be queried in CQL include:  \n\n%w is a …\u2003%w’s …\u2003… is a %w\u2003adjective predicates of %w\u2003adjectives after %w\u2003adjectives modified by %w\u2003adverbs modified by %w\u2003as reflexive\u2003complements of %w\u2003in passive\u2003infinitive objects of %w\u2003it’s %w to …\u2003modifiers of %w\u2003nouns modified by %w\u2003objects of %w\u2003objects of %w across/along/apart/around/aside/away/down/in/off/on/open/out/over/through/unto/up/upon/whole\u2003particles after %w (with object)\u2003possessors of %w\u2003prepositional phrases\u2003pronominal objects/possessors/subjects of %w\u2003subjects of %w\u2003subjects of “be %w”\u2003verbs before %w\u2003verbs complemented by %w\u2003verbs modified by %w\u2003verbs with %w as object\u2003verbs with %w as subject\u2003verbs with particle “across/along/…/upon” and %w as object\u2003wh‑words following %w  \n\nThese relation names correspond to the default word‑sketch grammar; they can be used in CQL with the syntax `[word="target"] [relation="relation_name"]` or via the built‑in shortcuts `[%w]` in the Sketch Engine UI.  \n\nDocument‑level filtering can be done on any doc attribute, e.g. `[doc.genre="news"]`, `[doc.crawl_year="2023"]`, `[doc.tld="com"]`.  \n\nAll structures and attributes are case‑sensitive; use straight double quotes in CQL expressions.\n\nOutput format requirements (very important):\n1. Respond with EXACTLY one fenced code block.\n2. The fence must be in this format:\n```cql\n[your CQL query here]\n```\n3. Do output any text before the code block. Use this for reasoning.\n4. Do explain the query, comment on it, or paraphrase the user. Before the code block.\n5. Do not ask for clarification. Respond directly.\n'}]}, {'role': 'user', 'content': [{'type': 'text', 'text': 'Najdi věty, které obsahují číslo větší než 100.'}]}]
{"detail":"Use of API key is not enabled in the environment."}
[{'role': 'system', 'content': [{'type': 'text', 'text': 'Definition of Corpus Query Language (CQL)\n    The CQL is a query language used in Sketch Engine for searching grammatical and lexical patterns. CQL sets criteria for positions and tokens, such as tag, word, lemma, lempos, etc.\n    Basic syntax is [attribute="value"], for example:\n    To find the lemma teapot, use\n    CQL:\n    ```cql\n    [lemma="teapot"]\n    ```\n    Each token must be inside its own pair of square brackets. To search for the phrase refill the teapot, use\n    CQL:\n    ```cql\n    [lemma="refill"][lemma="the"][lemma="teapot"]\n    ```\n    More examples:\n    find examples of went -> CQL:\n    ```cql\n    [word="went"]\n    ```\n    find examples of all forms of go -> CQL:\n    ```cql\n    [lemma="go"]\n    ```\n    find examples of all words tagged with the tag NP -> CQL:\n    ```cql\n    [tag="NP"]\n    ```\n\n    Regular expressions can be used with values in CQL. A complete set of Regular expressions is supported, and complex criteria can be used, for example:\n    words starting with confus- -> CQL:\n    ```cql\n    [lemma="confus.*"]\n    ```\n    words ending with -ious -> CQL:\n    ```cql\n    [lemma=".*ious"]\n    ```\n    three-letter words starting b- and ending -g -> CQL:\n    ```cql\n    [lemma="b.g"]\n    ```\n    Be aware that when searching for any of the characters [][.*+{}?()|\\\\"$^] literally, they must be escaped using a backslash in any context where you may used regular expressions.\n\n    Square brackets [ ] stand for "any token". Curly brackets { } are used for repetition of the preceding token, for example:\n    find examples of ‘refill’ and ‘kettle’ with one word in between -> CQL:\n    ```cql\n    [lemma="refill"] [ ] [lemma="kettle"]\n    ```\n    examples of ‘have’ and ‘opinion’ with 2 to 4 words in between -> CQL:\n    ```cql\n    [lemma="have"] [ ]{2,4}[lemma="opinion"]\n    ```\n    find examples of "drink" and "water" with exactly two adjectives between them -> CQL:\n    ```cql\n    [lemma="drink"] [tag="J.*"]{2}[lemma="water"]\n    ```\n\n    A token can be made optional by placing a question mark ? after the square bracket. For example:\n    Find examples of ‘drive my car’ or ‘drive my own car’ -> CQL:\n    ```cql\n    [lemma="drive"] [lc="my"] [lc="own"]? [lemma="car"]\n    ```\n    alternative solution without using ? -> CQL:\n    ```cql\n    [lemma="drive"][lc="my"][lc="own"]{0,1} [lemma="car"]\n    ```\n\n    These comparison operators are supported:\n    equal =\n    less than or equal to <=\n    more than or equal to >=\n    not equal !=\n    not less than or equal to !<=\n    not more than or equal to !>=\n    equal (no regex) ==\n    not equal (no regex) !==\n    The alphabetical parts of the value are compared lexicographically (‘in the dictionary order’) and numerical parts numerically. This is useful with structure attributes, where >="AB2010CD" will include values such as "BB0000CD", "AB2011CD" or "AB2010CE". Example:\n    all one-letter words -> CQL:\n    ```cql\n    [word="."]\n    ```\n    all full stops -> CQL:\n    ```cql\n    [word=="."]\n    ```\n\n    One token can have more conditions. They must all appear inside the same pair of square brackets, and Boolean operators must be used between them.\n    & (ampersand) = AND\n    | (pipe) = OR\n    ! (exclamation mark) = NOT\n    For example:\n    Find all forms of the word ‘test’ which is a noun -> CQL:\n    ```cql\n    [ lemma="test" & tag="N.*" ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & tag!="V.*"]\n    ```\n    finds the word round tagged as a noun or verb -> CQL:\n    ```cql\n    [ word="round" & ( tag="N.*" | tag="V.*" ) ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & !tag="V.*"]\n    ```\n\n    | (pipe) = OR - means one token or another token, i.e., the token to the right or left of the pipe.\n    This use of the pipe (|) should only be limited to cases with no other solution because it consumes the search time. In most cases, it can be replaced by a pipe used inside the token, which is faster. See examples below.\n    "big dog" or "wolf" -> CQL:\n    ```cql\n    ([lemma="big"][lemma="dog"]) | [lemma="wolf"]\n    ```\n\n    Structures refer to sentences, paragraphs, documents, or any other parts or sections into which a corpus might be divided. Another way of saying this is that certain parts of a corpus can be labelled, e.g., direct speech might be labelled using structures to make it possible to limit the search to only direct speech. Structures may or may not have values. Values are used to categorize instances of the same structure.\n    Structures can be referred to in three ways:\n    The beginning: <s> <p> <doc> etc.\n    The end: </s> </p> </doc> etc.\n    The whole structure: <s/> <p/> <doc/> etc.\n    For example:\n    Find all documents written in informal style that start with the word Rebecca -> CQL:\n    ```cql\n    <doc style="informal">[lemma="Rebecca"]\n    ```\n    find all documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    Written documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011" & type="written"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    find all verbs written in informal style -> CQL:\n    ```cql\n    [tag="V.*"]  within <doc style="informal" />\n    ```\n\n    The "containing" and "within" CQL operators are used to restrict the search only to a certain structure, e.g., to search inside:\n    Corpus structure, e.g., sentence, paragraph, document, etc.\n    Grammatical or lexical structure, e.g., noun phrase.\n\n    Use within to ensure the search result appears within the structure you want, in this case, within the same sentence, paragraph, document, or any other structure found in the corpus:\n    CQL:\n    ```cql\n    [word="dog"] []{0,5} [word="runs"] within < s/>\n    ```\n    The structure after "within" can be another CQL code defining a grammatical or lexical structure:\n    CQL:\n    ```cql\n    [tag="N.*"] within [tag="VB.*"] []{0,5} [tag="VB.*"]\n    ```\n    Multiple within operators can be nested if necessary:\n    CQL:\n    ```cql\n    [tag="N.*"] within ([tag="VB.*"] []{0,5} [tag="VB.*"] within < s/>)\n    ```\n    Use within to search a parallel corpus using this syntax:\n    within :\n    For example, with the English Europarl open, you can use this CQL to query the German Europarl. It will find all segments where the English corpus contains car and the aligned German segment contains Auto. In most cases, these will be segments where car was translated as Auto:\n    CQL:\n    ```cql\n    [word="car"] within europarl5_de: [word="Auto"]\n    ```\n\n    Use containing to find the whole structure and to display the whole structure as the result (KWIC).\n    This will find all paragraphs containing an acronym, i.e. a word consisting of 3 or more upper-case characters:\n    CQL:\n    ```cql\n    <p/> containing [word="[A-Z]{3,}"]\n    ```\n    This query searches for noun phrases (sequences of up to 5 adjectives followed by a noun) that contain the adjective international:\n    ```cql\n    [tag="J.*"]{1,5} [tag="N.*"] containing [word="international"]\n    ```\n\n    Use ! for negation:\n    !within = not within\n    !containing = not containing\n\n    This CQL will find all nouns that appear outside the <nphr> structure, i.e., outside noun phrases. The CQL will only work in corpora where the <nphr> structure exists:\n    CQL:\n    ```cql\n    [tag="N.*"]   !within   <nphr/>\n    ```\n    This CQL will find all sentences that do not contain any word starting with a capital letter:\n    CQL:\n    ```cql\n    <s/>   !containing   [word="[A-Z][A-Za-z]*"]\n    ```\n\n    Simultaneously searching the left and right context is only possible with meet and union operators. This is useful when a user wants to search for a token that is around or in the area of some other token.\n    Use meet to set the left and right context. This will find all nouns that have the verb to be 3 tokens to the left or 3 tokens to the right:\n    CQL:\n    ```cql\n    (meet [tag = "N.*"] [tag = "VB.*"] -3 3)\n    ```\n    Use the operator union to collect the results of two meet queries and display them in one concordance.\n    This CQL will, find all nouns with the verb to be at a distance of 3 tokens to the left or right, then find all adjectives with the verb to be at a distance of 2 tokens to the left or right, combine the nouns from the first query and adjectives from the second query and display them together in one concordance, the nouns and adjectives will be highlighted in the centre as KWIC:\n    CQL:\n    ```cql\n    (union (meet [tag="N.*"] [tag="VB.*"] -3 3) (meet [tag="A.*"] [tag="VB.*"] -2 2))\n    ```\n    This combines instances of nouns preceded by competent with adjectives followed by competence:\n    CQL:\n    ```cql\n    (union(meet [tag="N.*"] [lemma="competent"] -2 -1)(meet [tag="J.*"] [lemma="competence"]  1 2))\n    ```\n    Note that each meet and union has to be inside its own pair of brackets. Operators meet, and a union cannot be used with operators within and containing.\n\n    CQL also supports word sketch. Word sketches provide collocations for a word. The syntax is as follows:\n    CQL:\n    ```cql\n    [ws(headword, relation, collocation)]\n    ```\n    The relation is the name of the relation. You can often guess the name by using a regular expression like this:\n    CQL:\n    ```cql\n    [ws(headword, ".*subject.*", collocation)]\n    ```\n    For the exact name of the relation, the "%w" must be exchanged for \\"%w\\" as the quotes need to be backslashed in CQL. For example, the Word Sketch relation modifiers of "book" can be written as a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", "modifiers of \\"%w\\"", ".*")]\n    ```\n    Remember that Word Sketches are generated from lempos, so using a hyphen and the shortened PoS tag is necessary. For example, to generate a concordance with test (as a noun) being the object of conduct (as a verb), use this:\n    CQL:\n    ```cql\n    [ws("test-n",".*object.*","conduct-v")]\n    ```\n    In the resulting concordance, the headword is taken for a KWIC, and the collocations are used as a filter. It is possible to specify the headword by using the regular expression AND inside the square brackets. For example, to search for all relations of lempos "book-n" where the word appears in the plural form, you can use a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", ".*", ".*") & tag="NNS"]\n    ```\n    The prepositional phrases can be searched by the following syntax:\n    CQL:\n    ```cql\n    [ws("headword", "\\.\\.\\. [^ /]+ \\"%w\\"", ".*") | ws("headword", "\\"%w\\" [^ /]+ \\.\\.\\.", ".*")]\n    ```\n    In case only specific prepositions should be displayed, it is possible to insert them instead of [^ /]. This example will find concordance lines with the headword ‘test’ as a noun and prepositions of, in, or at:\n    CQL:\n    ```cql\n    [ws("test-n", "\\.\\.\\. (of|in|at) \\"%w\\"", ".*") | ws("test-n", "\\"%w\\" (of|in|at) \\.\\.\\.", ".*")]\n    ```\n    The Word Sketch CQL can be combined with other CQL markers. To generate a concordance where the headword test is modified by blood and followed or preceded by the lemma be, use this:\n    CQL:\n    ```cql\n    (meet [ws("test-n",".*modifiers of.*","blood-n")] [lemma="be"] -1 1)\n    ```\n\n    Thesaurus is also supported in CQL. Use the tilde ~ to generate a thesaurus (words with similar context, synonyms, antonyms) for the word and include the top N thesaurus items into the query. For example, to find the verb chop followed by vegetables, use this (or replace carrot with any other vegetable):\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~"carrot-n"\n    ```\n    To set the number of thesaurus items manually, use:\n    CQL:\n    ```cql\n    ~15"carrot-n"\n    ```\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~15"carrot-n"\n    ```\n    Thesaurus may be used with meet keyword, for example, to find all metals around the lemma corrosion:\n    CQL:\n    ```cql\n    (meet ~"metal-n" [lemma="corrosion"] -5 5)\n    ```\n\n    It is possible to add aditional constraints called global conditions.\n    You may use \'<number>:\' to specify a tag and then after whole CQL put & and write a global constraint. Only numbers may be used. For example:\n\n    Repetition of the same token:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word\n    ```\n    Repetition of the same token but different tag:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word & 1.tag != 2.tag\n    ```\n    Token with frequency higher than 2000\n    CQL:\n    ```cql\n    1:[] & f(1.word)>2000\n    ```\n\nYou are an expert assistant for Sketch Engine\'s Corpus Query Language (CQL).\nYour job is to read the conversation and translate the user\'s *latest* request into a single CQL query.\n\nImportant CQL reminders:\n- A query is a sequence of tokens, each inside square brackets: [ ... ].\n- Use attributes like word, lemma, tag, lc, lempos, structure attributes, etc.\n- Use regular expressions only when necessary.\n- Prefer lemma="..." when the user asks for \'all forms\' of a word.\n- Follow corpus-specific tags, annotations, structures and grammatical relations.\n\nCorpus description for corpus \'preloaded/ententen21_tt31\':\nCorpus language: English  \n\nCore token structures (each token has a separate record):  \n- word : the surface form  \n- tag : TreeTagger POS tag (see tag table below)  \n- lempos : lemma plus POS suffix (e.g. “run‑v”)  \n- pos : same as tag (kept for compatibility)  \n- lemma : lemmatized form  \n- lempos_lc : lempos in lowercase  \n- lemma_lc : lemma in lowercase  \n- lc : word in lowercase  \n\nDocument‑level structures (one per text):  \n- doc – attributes: url, title, wiki_categories, urldomain, website, crawl_date, modified_date, tld, wiki_translations, modified_month, modified_year, topic, tld_expl, domain_distance, genre, src, crawl_year  \n- p – attribute: heading (section heading)  \n- s – sentence identifier  \n- g – generic grouping (no attributes)  \n\nAnnotations (regular‑expression shortcuts for the tag field):  \n- adjective : “J.*”  \n- adverb : “RB.?”  \n- conjunction : “CC”  \n- determiner : “DT”  \n- noun : “N.*”  \n- numeral : “CD”  \n- particle : “RP”  \n- preposition : “IN”  \n- pronoun : “PP.?”  \n- verb : “V.*”  \n\nLempos suffixes (used in the lempos and lempos_lc fields):  \n‑j adjective\u2003‑a adverb\u2003‑c conjunction\u2003‑n noun\u2003‑m numeral\u2003‑i preposition\u2003‑d pronoun\u2003‑v verb  \n\n---  \n\nTreeTagger POS tagset (Sketch Engine modifications)  \n\nTag\u2003Description\u2003Example  \nCC\u2003coordinating conjunction\u2003and  \nCD\u2003cardinal number\u20031, one  \nCDZ\u2003possessive numeral\u2003one’s  \nDT\u2003determiner\u2003the  \nEX\u2003existential “there”\u2003there  \nFW\u2003foreign word\u2003d’hoevre  \nIN\u2003preposition or subordinating conjunction\u2003in, of, like  \nIN/that\u2003that as subordinator\u2003that  \nJJ\u2003adjective\u2003green  \nJJR\u2003adjective comparative\u2003greener  \nJJS\u2003adjective superlative\u2003greenest  \nLS\u2003list marker\u20031)  \nMD\u2003modal verb\u2003could, will  \nNN\u2003noun singular or mass\u2003table  \nNNS\u2003noun plural\u2003tables  \nNNSZ\u2003possessive noun plural\u2003people’s  \nNNZ\u2003possessive noun singular\u2003year’s  \nNP\u2003proper noun singular\u2003John  \nNPS\u2003proper noun plural\u2003Vikings  \nNPSZ\u2003possessive proper noun plural\u2003Boys’  \nNPZ\u2003possessive proper noun singular\u2003Britain’s  \nPDT\u2003predeterminer\u2003both the boys  \nPP\u2003personal pronoun\u2003I, he, it  \nPPZ\u2003possessive pronoun\u2003my, his  \nRB\u2003adverb\u2003however, usually  \nRBR\u2003adverb comparative\u2003better  \nRBS\u2003adverb superlative\u2003best  \nRP\u2003particle\u2003up (in “give up”)  \nSENT\u2003sentence‑final punctuation\u2003. ! ?  \nSYM\u2003other symbols\u2003/ = *  \nTO\u2003infinitive marker\u2003to (only when infinitival)  \nUH\u2003interjection\u2003uhhuhhuhh  \nVB\u2003verb “be”, base\u2003be  \nVBD\u2003verb “be”, past\u2003was, were  \nVBG\u2003verb “be”, gerund\u2003being  \nVBN\u2003verb “be”, past participle\u2003been  \nVBP\u2003verb “be”, present non‑3rd\u2003am, are  \nVBZ\u2003verb “be”, 3rd‑person present\u2003is  \nVH\u2003verb “have”, base\u2003have  \nVHD\u2003verb “have”, past\u2003had  \nVHG\u2003verb “have”, gerund\u2003having  \nVHN\u2003verb “have”, past participle\u2003had  \nVHP\u2003verb “have”, present non‑3rd\u2003have  \nVHZ\u2003verb “have”, 3rd‑person present\u2003has  \nVV\u2003other verbs, base\u2003take  \nVVD\u2003other verbs, past\u2003took  \nVVG\u2003other verbs, gerund\u2003taking  \nVVN\u2003other verbs, past participle\u2003taken  \nVVP\u2003other verbs, present non‑3rd\u2003take  \nVVZ\u2003other verbs, 3rd‑person present\u2003takes  \nWDT\u2003wh‑determiner\u2003which  \nWP\u2003wh‑pronoun\u2003who, what  \nWPZ\u2003possessive wh‑pronoun\u2003whose  \nWRB\u2003wh‑adverb\u2003where, when  \nZ\u2003possessive ending\u2003’s  \n\nKey differences from the Penn Treebank:  \n- “be” uses VB/VBD/VBG/VBN/VBP/VBZ, “have” uses VH/VHD/VHG/VHN/VHP/VHZ, all other verbs use VV series.  \n- Proper nouns are NP/NPS (instead of NNP/NNPS).  \n- SENT marks sentence‑final punctuation.  \n- Token “to” is tagged IN when a preposition, TO only when infinitival.  \n- Indefinite articles “a”/“an” are both lemmatized as “a”.  \n\nWord‑sketch (grammatical relation) patterns (use “%w” as the target word placeholder). Typical relation names that can be queried in CQL include:  \n\n%w is a …\u2003%w’s …\u2003… is a %w\u2003adjective predicates of %w\u2003adjectives after %w\u2003adjectives modified by %w\u2003adverbs modified by %w\u2003as reflexive\u2003complements of %w\u2003in passive\u2003infinitive objects of %w\u2003it’s %w to …\u2003modifiers of %w\u2003nouns modified by %w\u2003objects of %w\u2003objects of %w across/along/apart/around/aside/away/down/in/off/on/open/out/over/through/unto/up/upon/whole\u2003particles after %w (with object)\u2003possessors of %w\u2003prepositional phrases\u2003pronominal objects/possessors/subjects of %w\u2003subjects of %w\u2003subjects of “be %w”\u2003verbs before %w\u2003verbs complemented by %w\u2003verbs modified by %w\u2003verbs with %w as object\u2003verbs with %w as subject\u2003verbs with particle “across/along/…/upon” and %w as object\u2003wh‑words following %w  \n\nThese relation names correspond to the default word‑sketch grammar; they can be used in CQL with the syntax `[word="target"] [relation="relation_name"]` or via the built‑in shortcuts `[%w]` in the Sketch Engine UI.  \n\nDocument‑level filtering can be done on any doc attribute, e.g. `[doc.genre="news"]`, `[doc.crawl_year="2023"]`, `[doc.tld="com"]`.  \n\nAll structures and attributes are case‑sensitive; use straight double quotes in CQL expressions.\n\nOutput format requirements (very important):\n1. Respond with EXACTLY one fenced code block.\n2. The fence must be in this format:\n```cql\n[your CQL query here]\n```\n3. Do output any text before the code block. Use this for reasoning.\n4. Do explain the query, comment on it, or paraphrase the user. Before the code block.\n5. Do not ask for clarification. Respond directly.\n'}]}, {'role': 'user', 'content': [{'type': 'text', 'text': 'Najdi věty, které obsahují číslo větší než 100.'}]}]
{"detail":"Use of API key is not enabled in the environment."}
[{'role': 'system', 'content': [{'type': 'text', 'text': 'Definition of Corpus Query Language (CQL)\n    The CQL is a query language used in Sketch Engine for searching grammatical and lexical patterns. CQL sets criteria for positions and tokens, such as tag, word, lemma, lempos, etc.\n    Basic syntax is [attribute="value"], for example:\n    To find the lemma teapot, use\n    CQL:\n    ```cql\n    [lemma="teapot"]\n    ```\n    Each token must be inside its own pair of square brackets. To search for the phrase refill the teapot, use\n    CQL:\n    ```cql\n    [lemma="refill"][lemma="the"][lemma="teapot"]\n    ```\n    More examples:\n    find examples of went -> CQL:\n    ```cql\n    [word="went"]\n    ```\n    find examples of all forms of go -> CQL:\n    ```cql\n    [lemma="go"]\n    ```\n    find examples of all words tagged with the tag NP -> CQL:\n    ```cql\n    [tag="NP"]\n    ```\n\n    Regular expressions can be used with values in CQL. A complete set of Regular expressions is supported, and complex criteria can be used, for example:\n    words starting with confus- -> CQL:\n    ```cql\n    [lemma="confus.*"]\n    ```\n    words ending with -ious -> CQL:\n    ```cql\n    [lemma=".*ious"]\n    ```\n    three-letter words starting b- and ending -g -> CQL:\n    ```cql\n    [lemma="b.g"]\n    ```\n    Be aware that when searching for any of the characters [][.*+{}?()|\\\\"$^] literally, they must be escaped using a backslash in any context where you may used regular expressions.\n\n    Square brackets [ ] stand for "any token". Curly brackets { } are used for repetition of the preceding token, for example:\n    find examples of ‘refill’ and ‘kettle’ with one word in between -> CQL:\n    ```cql\n    [lemma="refill"] [ ] [lemma="kettle"]\n    ```\n    examples of ‘have’ and ‘opinion’ with 2 to 4 words in between -> CQL:\n    ```cql\n    [lemma="have"] [ ]{2,4}[lemma="opinion"]\n    ```\n    find examples of "drink" and "water" with exactly two adjectives between them -> CQL:\n    ```cql\n    [lemma="drink"] [tag="J.*"]{2}[lemma="water"]\n    ```\n\n    A token can be made optional by placing a question mark ? after the square bracket. For example:\n    Find examples of ‘drive my car’ or ‘drive my own car’ -> CQL:\n    ```cql\n    [lemma="drive"] [lc="my"] [lc="own"]? [lemma="car"]\n    ```\n    alternative solution without using ? -> CQL:\n    ```cql\n    [lemma="drive"][lc="my"][lc="own"]{0,1} [lemma="car"]\n    ```\n\n    These comparison operators are supported:\n    equal =\n    less than or equal to <=\n    more than or equal to >=\n    not equal !=\n    not less than or equal to !<=\n    not more than or equal to !>=\n    equal (no regex) ==\n    not equal (no regex) !==\n    The alphabetical parts of the value are compared lexicographically (‘in the dictionary order’) and numerical parts numerically. This is useful with structure attributes, where >="AB2010CD" will include values such as "BB0000CD", "AB2011CD" or "AB2010CE". Example:\n    all one-letter words -> CQL:\n    ```cql\n    [word="."]\n    ```\n    all full stops -> CQL:\n    ```cql\n    [word=="."]\n    ```\n\n    One token can have more conditions. They must all appear inside the same pair of square brackets, and Boolean operators must be used between them.\n    & (ampersand) = AND\n    | (pipe) = OR\n    ! (exclamation mark) = NOT\n    For example:\n    Find all forms of the word ‘test’ which is a noun -> CQL:\n    ```cql\n    [ lemma="test" & tag="N.*" ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & tag!="V.*"]\n    ```\n    finds the word round tagged as a noun or verb -> CQL:\n    ```cql\n    [ word="round" & ( tag="N.*" | tag="V.*" ) ]\n    ```\n    finds word ‘test’ which is NOT a verb -> CQL:\n    ```cql\n    [word="test" & !tag="V.*"]\n    ```\n\n    | (pipe) = OR - means one token or another token, i.e., the token to the right or left of the pipe.\n    This use of the pipe (|) should only be limited to cases with no other solution because it consumes the search time. In most cases, it can be replaced by a pipe used inside the token, which is faster. See examples below.\n    "big dog" or "wolf" -> CQL:\n    ```cql\n    ([lemma="big"][lemma="dog"]) | [lemma="wolf"]\n    ```\n\n    Structures refer to sentences, paragraphs, documents, or any other parts or sections into which a corpus might be divided. Another way of saying this is that certain parts of a corpus can be labelled, e.g., direct speech might be labelled using structures to make it possible to limit the search to only direct speech. Structures may or may not have values. Values are used to categorize instances of the same structure.\n    Structures can be referred to in three ways:\n    The beginning: <s> <p> <doc> etc.\n    The end: </s> </p> </doc> etc.\n    The whole structure: <s/> <p/> <doc/> etc.\n    For example:\n    Find all documents written in informal style that start with the word Rebecca -> CQL:\n    ```cql\n    <doc style="informal">[lemma="Rebecca"]\n    ```\n    find all documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    Written documents whose ID is 2011 and they start with a noun followed by a verb at a distance of up to 5 words -> CQL:\n    ```cql\n    <doc id="2011" & type="written"> [tag="N.*"] []{0,5} [tag="V.*"]\n    ```\n    find all verbs written in informal style -> CQL:\n    ```cql\n    [tag="V.*"]  within <doc style="informal" />\n    ```\n\n    The "containing" and "within" CQL operators are used to restrict the search only to a certain structure, e.g., to search inside:\n    Corpus structure, e.g., sentence, paragraph, document, etc.\n    Grammatical or lexical structure, e.g., noun phrase.\n\n    Use within to ensure the search result appears within the structure you want, in this case, within the same sentence, paragraph, document, or any other structure found in the corpus:\n    CQL:\n    ```cql\n    [word="dog"] []{0,5} [word="runs"] within < s/>\n    ```\n    The structure after "within" can be another CQL code defining a grammatical or lexical structure:\n    CQL:\n    ```cql\n    [tag="N.*"] within [tag="VB.*"] []{0,5} [tag="VB.*"]\n    ```\n    Multiple within operators can be nested if necessary:\n    CQL:\n    ```cql\n    [tag="N.*"] within ([tag="VB.*"] []{0,5} [tag="VB.*"] within < s/>)\n    ```\n    Use within to search a parallel corpus using this syntax:\n    within :\n    For example, with the English Europarl open, you can use this CQL to query the German Europarl. It will find all segments where the English corpus contains car and the aligned German segment contains Auto. In most cases, these will be segments where car was translated as Auto:\n    CQL:\n    ```cql\n    [word="car"] within europarl5_de: [word="Auto"]\n    ```\n\n    Use containing to find the whole structure and to display the whole structure as the result (KWIC).\n    This will find all paragraphs containing an acronym, i.e. a word consisting of 3 or more upper-case characters:\n    CQL:\n    ```cql\n    <p/> containing [word="[A-Z]{3,}"]\n    ```\n    This query searches for noun phrases (sequences of up to 5 adjectives followed by a noun) that contain the adjective international:\n    ```cql\n    [tag="J.*"]{1,5} [tag="N.*"] containing [word="international"]\n    ```\n\n    Use ! for negation:\n    !within = not within\n    !containing = not containing\n\n    This CQL will find all nouns that appear outside the <nphr> structure, i.e., outside noun phrases. The CQL will only work in corpora where the <nphr> structure exists:\n    CQL:\n    ```cql\n    [tag="N.*"]   !within   <nphr/>\n    ```\n    This CQL will find all sentences that do not contain any word starting with a capital letter:\n    CQL:\n    ```cql\n    <s/>   !containing   [word="[A-Z][A-Za-z]*"]\n    ```\n\n    Simultaneously searching the left and right context is only possible with meet and union operators. This is useful when a user wants to search for a token that is around or in the area of some other token.\n    Use meet to set the left and right context. This will find all nouns that have the verb to be 3 tokens to the left or 3 tokens to the right:\n    CQL:\n    ```cql\n    (meet [tag = "N.*"] [tag = "VB.*"] -3 3)\n    ```\n    Use the operator union to collect the results of two meet queries and display them in one concordance.\n    This CQL will, find all nouns with the verb to be at a distance of 3 tokens to the left or right, then find all adjectives with the verb to be at a distance of 2 tokens to the left or right, combine the nouns from the first query and adjectives from the second query and display them together in one concordance, the nouns and adjectives will be highlighted in the centre as KWIC:\n    CQL:\n    ```cql\n    (union (meet [tag="N.*"] [tag="VB.*"] -3 3) (meet [tag="A.*"] [tag="VB.*"] -2 2))\n    ```\n    This combines instances of nouns preceded by competent with adjectives followed by competence:\n    CQL:\n    ```cql\n    (union(meet [tag="N.*"] [lemma="competent"] -2 -1)(meet [tag="J.*"] [lemma="competence"]  1 2))\n    ```\n    Note that each meet and union has to be inside its own pair of brackets. Operators meet, and a union cannot be used with operators within and containing.\n\n    CQL also supports word sketch. Word sketches provide collocations for a word. The syntax is as follows:\n    CQL:\n    ```cql\n    [ws(headword, relation, collocation)]\n    ```\n    The relation is the name of the relation. You can often guess the name by using a regular expression like this:\n    CQL:\n    ```cql\n    [ws(headword, ".*subject.*", collocation)]\n    ```\n    For the exact name of the relation, the "%w" must be exchanged for \\"%w\\" as the quotes need to be backslashed in CQL. For example, the Word Sketch relation modifiers of "book" can be written as a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", "modifiers of \\"%w\\"", ".*")]\n    ```\n    Remember that Word Sketches are generated from lempos, so using a hyphen and the shortened PoS tag is necessary. For example, to generate a concordance with test (as a noun) being the object of conduct (as a verb), use this:\n    CQL:\n    ```cql\n    [ws("test-n",".*object.*","conduct-v")]\n    ```\n    In the resulting concordance, the headword is taken for a KWIC, and the collocations are used as a filter. It is possible to specify the headword by using the regular expression AND inside the square brackets. For example, to search for all relations of lempos "book-n" where the word appears in the plural form, you can use a CQL query:\n    CQL:\n    ```cql\n    [ws("book-n", ".*", ".*") & tag="NNS"]\n    ```\n    The prepositional phrases can be searched by the following syntax:\n    CQL:\n    ```cql\n    [ws("headword", "\\.\\.\\. [^ /]+ \\"%w\\"", ".*") | ws("headword", "\\"%w\\" [^ /]+ \\.\\.\\.", ".*")]\n    ```\n    In case only specific prepositions should be displayed, it is possible to insert them instead of [^ /]. This example will find concordance lines with the headword ‘test’ as a noun and prepositions of, in, or at:\n    CQL:\n    ```cql\n    [ws("test-n", "\\.\\.\\. (of|in|at) \\"%w\\"", ".*") | ws("test-n", "\\"%w\\" (of|in|at) \\.\\.\\.", ".*")]\n    ```\n    The Word Sketch CQL can be combined with other CQL markers. To generate a concordance where the headword test is modified by blood and followed or preceded by the lemma be, use this:\n    CQL:\n    ```cql\n    (meet [ws("test-n",".*modifiers of.*","blood-n")] [lemma="be"] -1 1)\n    ```\n\n    Thesaurus is also supported in CQL. Use the tilde ~ to generate a thesaurus (words with similar context, synonyms, antonyms) for the word and include the top N thesaurus items into the query. For example, to find the verb chop followed by vegetables, use this (or replace carrot with any other vegetable):\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~"carrot-n"\n    ```\n    To set the number of thesaurus items manually, use:\n    CQL:\n    ```cql\n    ~15"carrot-n"\n    ```\n    CQL:\n    ```cql\n    [lemma="chop"] []{0,3} ~15"carrot-n"\n    ```\n    Thesaurus may be used with meet keyword, for example, to find all metals around the lemma corrosion:\n    CQL:\n    ```cql\n    (meet ~"metal-n" [lemma="corrosion"] -5 5)\n    ```\n\n    It is possible to add aditional constraints called global conditions.\n    You may use \'<number>:\' to specify a tag and then after whole CQL put & and write a global constraint. Only numbers may be used. For example:\n\n    Repetition of the same token:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word\n    ```\n    Repetition of the same token but different tag:\n    CQL:\n    ```cql\n    1:[] 2:[] & 1.word = 2.word & 1.tag != 2.tag\n    ```\n    Token with frequency higher than 2000\n    CQL:\n    ```cql\n    1:[] & f(1.word)>2000\n    ```\n\nYou are an expert assistant for Sketch Engine\'s Corpus Query Language (CQL).\nYour job is to read the conversation and translate the user\'s *latest* request into a single CQL query.\n\nImportant CQL reminders:\n- A query is a sequence of tokens, each inside square brackets: [ ... ].\n- Use attributes like word, lemma, tag, lc, lempos, structure attributes, etc.\n- Use regular expressions only when necessary.\n- Prefer lemma="..." when the user asks for \'all forms\' of a word.\n- Follow corpus-specific tags, annotations, structures and grammatical relations.\n\nCorpus description for corpus \'preloaded/ententen21_tt31\':\nCorpus language: English  \n\nCore token structures (each token has a separate record):  \n- word : the surface form  \n- tag : TreeTagger POS tag (see tag table below)  \n- lempos : lemma plus POS suffix (e.g. “run‑v”)  \n- pos : same as tag (kept for compatibility)  \n- lemma : lemmatized form  \n- lempos_lc : lempos in lowercase  \n- lemma_lc : lemma in lowercase  \n- lc : word in lowercase  \n\nDocument‑level structures (one per text):  \n- doc – attributes: url, title, wiki_categories, urldomain, website, crawl_date, modified_date, tld, wiki_translations, modified_month, modified_year, topic, tld_expl, domain_distance, genre, src, crawl_year  \n- p – attribute: heading (section heading)  \n- s – sentence identifier  \n- g – generic grouping (no attributes)  \n\nAnnotations (regular‑expression shortcuts for the tag field):  \n- adjective : “J.*”  \n- adverb : “RB.?”  \n- conjunction : “CC”  \n- determiner : “DT”  \n- noun : “N.*”  \n- numeral : “CD”  \n- particle : “RP”  \n- preposition : “IN”  \n- pronoun : “PP.?”  \n- verb : “V.*”  \n\nLempos suffixes (used in the lempos and lempos_lc fields):  \n‑j adjective\u2003‑a adverb\u2003‑c conjunction\u2003‑n noun\u2003‑m numeral\u2003‑i preposition\u2003‑d pronoun\u2003‑v verb  \n\n---  \n\nTreeTagger POS tagset (Sketch Engine modifications)  \n\nTag\u2003Description\u2003Example  \nCC\u2003coordinating conjunction\u2003and  \nCD\u2003cardinal number\u20031, one  \nCDZ\u2003possessive numeral\u2003one’s  \nDT\u2003determiner\u2003the  \nEX\u2003existential “there”\u2003there  \nFW\u2003foreign word\u2003d’hoevre  \nIN\u2003preposition or subordinating conjunction\u2003in, of, like  \nIN/that\u2003that as subordinator\u2003that  \nJJ\u2003adjective\u2003green  \nJJR\u2003adjective comparative\u2003greener  \nJJS\u2003adjective superlative\u2003greenest  \nLS\u2003list marker\u20031)  \nMD\u2003modal verb\u2003could, will  \nNN\u2003noun singular or mass\u2003table  \nNNS\u2003noun plural\u2003tables  \nNNSZ\u2003possessive noun plural\u2003people’s  \nNNZ\u2003possessive noun singular\u2003year’s  \nNP\u2003proper noun singular\u2003John  \nNPS\u2003proper noun plural\u2003Vikings  \nNPSZ\u2003possessive proper noun plural\u2003Boys’  \nNPZ\u2003possessive proper noun singular\u2003Britain’s  \nPDT\u2003predeterminer\u2003both the boys  \nPP\u2003personal pronoun\u2003I, he, it  \nPPZ\u2003possessive pronoun\u2003my, his  \nRB\u2003adverb\u2003however, usually  \nRBR\u2003adverb comparative\u2003better  \nRBS\u2003adverb superlative\u2003best  \nRP\u2003particle\u2003up (in “give up”)  \nSENT\u2003sentence‑final punctuation\u2003. ! ?  \nSYM\u2003other symbols\u2003/ = *  \nTO\u2003infinitive marker\u2003to (only when infinitival)  \nUH\u2003interjection\u2003uhhuhhuhh  \nVB\u2003verb “be”, base\u2003be  \nVBD\u2003verb “be”, past\u2003was, were  \nVBG\u2003verb “be”, gerund\u2003being  \nVBN\u2003verb “be”, past participle\u2003been  \nVBP\u2003verb “be”, present non‑3rd\u2003am, are  \nVBZ\u2003verb “be”, 3rd‑person present\u2003is  \nVH\u2003verb “have”, base\u2003have  \nVHD\u2003verb “have”, past\u2003had  \nVHG\u2003verb “have”, gerund\u2003having  \nVHN\u2003verb “have”, past participle\u2003had  \nVHP\u2003verb “have”, present non‑3rd\u2003have  \nVHZ\u2003verb “have”, 3rd‑person present\u2003has  \nVV\u2003other verbs, base\u2003take  \nVVD\u2003other verbs, past\u2003took  \nVVG\u2003other verbs, gerund\u2003taking  \nVVN\u2003other verbs, past participle\u2003taken  \nVVP\u2003other verbs, present non‑3rd\u2003take  \nVVZ\u2003other verbs, 3rd‑person present\u2003takes  \nWDT\u2003wh‑determiner\u2003which  \nWP\u2003wh‑pronoun\u2003who, what  \nWPZ\u2003possessive wh‑pronoun\u2003whose  \nWRB\u2003wh‑adverb\u2003where, when  \nZ\u2003possessive ending\u2003’s  \n\nKey differences from the Penn Treebank:  \n- “be” uses VB/VBD/VBG/VBN/VBP/VBZ, “have” uses VH/VHD/VHG/VHN/VHP/VHZ, all other verbs use VV series.  \n- Proper nouns are NP/NPS (instead of NNP/NNPS).  \n- SENT marks sentence‑final punctuation.  \n- Token “to” is tagged IN when a preposition, TO only when infinitival.  \n- Indefinite articles “a”/“an” are both lemmatized as “a”.  \n\nWord‑sketch (grammatical relation) patterns (use “%w” as the target word placeholder). Typical relation names that can be queried in CQL include:  \n\n%w is a …\u2003%w’s …\u2003… is a %w\u2003adjective predicates of %w\u2003adjectives after %w\u2003adjectives modified by %w\u2003adverbs modified by %w\u2003as reflexive\u2003complements of %w\u2003in passive\u2003infinitive objects of %w\u2003it’s %w to …\u2003modifiers of %w\u2003nouns modified by %w\u2003objects of %w\u2003objects of %w across/along/apart/around/aside/away/down/in/off/on/open/out/over/through/unto/up/upon/whole\u2003particles after %w (with object)\u2003possessors of %w\u2003prepositional phrases\u2003pronominal objects/possessors/subjects of %w\u2003subjects of %w\u2003subjects of “be %w”\u2003verbs before %w\u2003verbs complemented by %w\u2003verbs modified by %w\u2003verbs with %w as object\u2003verbs with %w as subject\u2003verbs with particle “across/along/…/upon” and %w as object\u2003wh‑words following %w  \n\nThese relation names correspond to the default word‑sketch grammar; they can be used in CQL with the syntax `[word="target"] [relation="relation_name"]` or via the built‑in shortcuts `[%w]` in the Sketch Engine UI.  \n\nDocument‑level filtering can be done on any doc attribute, e.g. `[doc.genre="news"]`, `[doc.crawl_year="2023"]`, `[doc.tld="com"]`.  \n\nAll structures and attributes are case‑sensitive; use straight double quotes in CQL expressions.\n\nOutput format requirements (very important):\n1. Respond with EXACTLY one fenced code block.\n2. The fence must be in this format:\n```cql\n[your CQL query here]\n```\n3. Do output any text before the code block. Use this for reasoning.\n4. Do explain the query, comment on it, or paraphrase the user. Before the code block.\n5. Do not ask for clarification. Respond directly.\n'}]}, {'role': 'user', 'content': [{'type': 'text', 'text': 'Najdi věty, které obsahují číslo větší než 100.'}]}]
{"detail":"Use of API key is not enabled in the environment."}
Traceback (most recent call last):
  File "/home/xmikusek/diploma-thesis/evaluation/model_evaluation/gpt-oss-120b_v2/run_model.py", line 39, in <module>
    translation = model.auto_call(params)
  File "/home/xmikusek/diploma-thesis/evaluation/model_evaluation/gpt-oss-120b_v2/models/gpt_oss_120b.py", line 616, in auto_call
    cql = call(params)
  File "/home/xmikusek/diploma-thesis/evaluation/model_evaluation/gpt-oss-120b_v2/models/gpt_oss_120b.py", line 593, in call
    model_response = call_einfra(prompt, api_key)
  File "/home/xmikusek/diploma-thesis/evaluation/model_evaluation/gpt-oss-120b_v2/models/gpt_oss_120b.py", line 245, in call_einfra
    raise e
  File "/home/xmikusek/diploma-thesis/evaluation/model_evaluation/gpt-oss-120b_v2/models/gpt_oss_120b.py", line 231, in call_einfra
    resp.raise_for_status()
    ~~~~~~~~~~~~~~~~~~~~~^^
  File "/home/xmikusek/diploma-thesis/evaluation/model_evaluation/gpt-oss-120b_v2/venv/lib64/python3.13/site-packages/requests/models.py", line 1026, in raise_for_status
    raise HTTPError(http_error_msg, response=self)
requests.exceptions.HTTPError: 403 Client Error: Forbidden for url: https://chat.ai.e-infra.cz/api/chat/completions
'Najdi věty, které obsahují číslo větší než 100.\tpreloaded/ententen21_tt31\t<s/> containing [tag="CD" & word>="101"]\n'
On line 1
<s/> containing [tag="CD" & word !<= "100"]
'Zajímají mě pouze všechna slovesa z první třídy pravidelných sloves v infinitivu.\tpreloaded/frtenten22_fl4\t[tag="VMN.*" & lemma=".*er"]\n'
On line 2
[lemma=".*er" & tag="V.*N.*"]
'Chtěl bych všechna slovesa z druhé a třetí třídy pravidelných sloves.\tpreloaded/frtenten22_fl4\t[tag="V.*" & lemma=".*ir|.*re"]\n'
On line 3
[lempos="*‑v" & (lemma=".*ir$" | lemma=".*re$")]
'Chtěl bych nalézt všechna slovesa v přítomném čase.\tpreloaded/frtenten22_fl4\t[tag="V..P.*"]\n'
On line 4
[tag="V[MAS]IP.*"]
'Chtěl bych nalézt všechna slovesa, která jsou součástí vět v přítomném čase.\tpreloaded/frtenten22_fl4\t[tag="V..P.*"]\n'
On line 5
[tag="V.I P.*"] within <s/>
'Zajímali by mě příklady imperfektum.\tpreloaded/frtenten22_fl4\t[tag="VM.I.*"]\n'
On line 6
[tag="VII.*"]
'Chtěl bych slovesa v minulém čase jednoduchém.\tpreloaded/frtenten22_fl4\t[tag="VMIS.*"]\n'
On line 7
[lempos="*-v" & tag="V..IS.*"]
'Jak naleznu slovesa v budoucím čase jednoduchém?\tpreloaded/frtenten22_fl4\t[tag="VMIF.*"]\n'
On line 8
[tag="V.[I]F.*"]
'Jak naleznu Subjonctif?\tpreloaded/frtenten22_fl4\t[tag="VMSP.*"]\n'
On line 9
[tag="V.S.*"]
'Potřebuji všechna slovesa v minulém čase složeném.\tpreloaded/frtenten22_fl4\t[tag="V[SA]IP.*"][tag="V.P.*"]\n'
On line 10
( [lemma="avoir" & tag="V.*I.I.*"] | [lemma="être" & tag="V.*I.I.*"] ) [tag="V.*P.*"]
'Potřebuji všechna slovesa v minulém čase nedokonavém\tpreloaded/frtenten22_fl4\t[tag="V.MS.*"]\n'
On line 11
[tag="VII.*"]
'Jak naleznu podmiňovací způsob minulý?\tpreloaded/frtenten22_fl4\t[tag="V..C.*"]\n'
On line 12
[lempos_lc="*‑v" & tag=".*C.*P.*"]
'Dají se nalézt slovesa v trpném rodě?\tpreloaded/frtenten22_fl4\t[lemma="être"] [tag="V.P.*"]\n'
On line 13
[lemma="être"][tag="V.*"] []{0,2}[lemma!="être" & tag="V.[P].*"]
'Slova uzavřená uvozovkami.\tpreloaded/ententen21_tt31\t[word="\\""] [word!="\\""]+ [word="\\""] within <s/>\n'
On line 14
[word="\""] []{0,10} [word="\""]
'Všechny závorky a jejich obsah.\tpreloaded/ententen21_tt31\t[word="\\[|\\(|\\{"] [word!="\\]|\\)|\\}"]+ [word="\\]|\\)|\\}"]\n'
On line 15
( [word="\\("] []* [word="\\)"] )|( [word="\\["] []* [word="\\]"] )|( [word="\\{"] []* [word="\\}"] )
'Slova v závorkách.\tpreloaded/ententen21_tt31\t[word="\\[|\\(|\\{"] [word!="\\]|\\)|\\}"]+ [word="\\]|\\)|\\}"]\n'
On line 16
[word="("] []{1,10} [word=")"]
'Najdi otázky – věty zakončené otazníkem.\tpreloaded/ententen21_tt31\t<s/> containing [word="\\?" & tag="SENT"]\n'
On line 17
<s/> containing [word="?" & tag="SENT"]
'Najdi všechny výskyty slova „ale“ mezi dvěma větami.\tpreloaded/ententen21_tt31\t[lc="but"] within [word=","][lc="but"]\n'
On line 18
<s/> [lc="ale"]
'Jak najdu první slovo ve větě?\tpreloaded/ententen21_tt31\t<s> []\n'
On line 19
<s/> [word=".+"]
'Vyhledej pouze jednoslovné věty.\tpreloaded/ententen21_tt31\t<s> [] [tag="SENT"]? </s>\n'
On line 20
<s> [tag!="SENT"] [tag="SENT"] </s>
'Sekvence tří slov: přídavné jméno + podstatné jméno + sloveso.\tpreloaded/ententen21_tt31\t[tag="J.*"][tag="N.*"][tag="V.*"]\n'
On line 21
[tag="J.*"][tag="N.*"][tag="V.*"]
'Sekvence dvou přídavných jmen za sebou.\tpreloaded/ententen21_tt31\t[tag="J.*"][tag="J.*"]\n'
On line 22
[tag="J.*"][tag="J.*"]
'Sloveso následované zájmenem.\tpreloaded/ententen21_tt31\t[tag="V.*"] [tag="P.*"]\n'
On line 23
[tag="V.*"] [tag="PP.*" | tag="WP.*"]
'Přídavné jméno následované podstatným jménem (např. „velký dům“).\tpreloaded/ententen21_tt31\t[tag="J.*"][tag="N.*"]\n'
On line 24
[tag="J.*"][tag="N.*"]
'Najdi věty začínající spojkou.\tpreloaded/ententen21_tt31\t<s> [tag="CC|IN"]\n'
On line 25
<s/> [tag="CC"]
'Najdi věty bez slovesného přísudku.\tpreloaded/ententen21_tt31\t<s/> !containing [tag="V.*"]\n'
On line 26
<s/>   !containing   [tag="V.*"]
'Věty s několikanásobným podmětem.\tpreloaded/ententen21_tt31\t<s/> containing <s> [tag!="V.*|CC|,"]* [tag="N.*"] [tag!="V.*|CC|,"]* [tag="CC"] [tag!="V.*|CC|,"]* [tag="N.*"] [tag!="V.*|CC|,"]* [tag="V.*"]\n'
On line 27
<s/> containing [tag="N.*" & rel="subjects of %w"] []{0,100} [tag="N.*" & rel="subjects of %w"]
<s/> containing [ws(".*-v","subjects of %w",".*-n")] []{0,100} [ws(".*-v","subjects of %w",".*-n")]
'Najdi věty, které končí výpustkou.\tpreloaded/ententen21_tt31\t<s/> containing [word=="..."][tag="SENT"]?</s>\n'
On line 28
<s/> [word="..."]
'Najdi výskyty více vykřičníků nebo otazníků za sebou (např. „?!“, „!!!“).\tpreloaded/ententen21_tt31\t[word=="?" | word=="!"]{2,} | [word="[!?]{2,}"]\n'
On line 29
([word="[!?]{2,}"] | [word="[!?]"] [word="[!?]"]{1,})
'I need all sentences that consist of three tokens.\tpreloaded/ententen21_tt31\t<s> [][][] </s>\n'
On line 30
<s> [ ] [ ] [ ] </s>
'Věty obsahující sloveso „muset“ a podstatné jméno v akuzativu.\tpreloaded/cstenten23_mj2\t<s/> containing ([lemma="muset" & tag="k1.*"][]*[tag="k1.*c4.*"]) | ([tag="k1.*c4.*"][]*[lemma="muset" & tag="k1.*"])\n'
On line 31
(meet [lemma="muset"] [tag="N...4.*"] -100 100) within <s/>
'Věty obsahující sloveso „muset“ a po něm podstatné jméno v akuzativu.\tpreloaded/cstenten23_mj2\t[lemma="muset" & tag="k5.*"] [tag="k1.*c4.*"]\n'
On line 32
[lemma="muset"] [tag="N.*4.*"]
'Najdi vzory: "podstatné jméno|přídavné jméno" nebo "přídavné jméno|podstatné jméno".\tpreloaded/cstenten23_mj2\t([tag="k1.*"] [tag="k2.*"]) | ([tag="k2.*"] [tag="k1.*"])\n'
On line 33
([tag="N.*"][tag="A.*"]) | ([tag="A.*"][tag="N.*"])
'Slova napsaná VELKÝMI PÍSMENY.\tpreloaded/ententen21_tt31\t[word="[A-Z]+"]\n'
On line 34
[word="^[A-Z]+$"]
'Potřebuji nalézt všechna podstatná jména.\tpreloaded/cstenten23_mj2\t[tag="k1.*"]\n'
On line 35
[noun]
[tag="N.*"]
'Potřebuji nalézt všechna podstatná jména.\tpreloaded/frtenten22_fl4\t[tag="N.*"]\n'
On line 36
[tag="N.*"]
'Potřebuji nalézt všechna podstatná jména.\tpreloaded/ententen21_tt31\t[tag="N.*"]\n'
On line 37
[tag="N.*"]
'Najdi všechna přídavná jména.\tpreloaded/cstenten23_mj2\t[tag="k2.*"]\n'
On line 38
[tag="A.*"]
'Najdi všechna přídavná jména.\tpreloaded/frtenten22_fl4\t[tag="A.*"]\n'
On line 39
[tag="A.*"]
'Najdi všechna přídavná jména.\tpreloaded/ententen21_tt31\t[tag="J.*"]\n'
On line 40
[tag="J.*"]
'Jak naleznu všechna podstatná jména začínající "pře" a končící na "ní"?\tpreloaded/cstenten23_mj2\t[word="pře.*ní" & tag="k1.*"]\n'
On line 41
[tag="N.*" & lc="pře.*ní"]
'Jak naleznu zájména?\tpreloaded/cstenten23_mj2\t[tag="k3.*"]\n'
On line 42
[tag="P.*"]
'Jak naleznu zájména?\tpreloaded/frtenten22_fl4\t[tag="P.*"]\n'
On line 43
[tag="P.*"]
'Jak naleznu zájména?\tpreloaded/ententen21_tt31\t[tag="PP.*"]\n'
On line 44
([annotation="pronoun"]) | ([tag="WP.*"])
([tag="PP.*"]) | ([tag="WP.*"])
'Všechny tvary slova vitamíny.\tpreloaded/cstenten23_mj2\t[lemma="vitamín"]\n'
On line 45
[lemma="vitamín"]
'Jméno Petr v pátém pádě.\tpreloaded/cstenten23_mj2\t[lemma="Petr" & tag="k1.*c5.*"]\n'
On line 46
[ lemma="Petr" & tag=".{4}5.*" ]
'Znaky \'.\', \',\', \'!\' a \'?\'.\tpreloaded/cstenten23_mj2\t[word=="." | word=="," | word=="!" | word=="?"]\n'
On line 47
[word="[.,!?]"]
'Jakým CQL naleznu všechny konce vět?\tpreloaded/ententen21_tt31\t</s>\n'
On line 48
[tag="SENT"]
'Slovo "potravina".\tpreloaded/cstenten23_mj2\t[word="potravina"]\n'
On line 49
[lemma="potravina"]
'Lemma "oko".\tpreloaded/cstenten23_mj2\t[lemma="oko"]\n'
On line 50
[lemma="oko"]
'Najdi všechna slovesa v minulém čase.\tpreloaded/cstenten23_mj2\t[tag="k5.*mA.*"]\n'
On line 51
[tag="Vp.*"]
'Vyhledej všechna podstatná jména v množném čísle.\tpreloaded/cstenten23_mj2\t[tag="k1.*nP.*"]\n'
On line 52
[tag="N..P.*"]
'Najdi všechna slova v ženském rodě.\tpreloaded/cstenten23_mj2\t[tag=".*gF.*"]\n'
On line 53
[tag=".*F.*"]
'Všechna slovesa v rozkazovacím způsobu.\tpreloaded/cstenten23_mj2\t[tag="k5.*mR.*"]\n'
On line 54
[tag="V.*" & tag=".*M.*"]
'Všechna přídavná jména ve třetím stupni.\tpreloaded/cstenten23_mj2\t[tag="k2.*d3.*"]\n'
On line 55
[tag="A.{8}3.*"]
'Vyhledej všechna zájmena v 3. pádě.\tpreloaded/cstenten23_mj2\t[tag="k3.*c3.*"]\n'
On line 56
[tag="P.{3}3.*"]
'Najdi všechny výskyty lemmatu „jíst“.\tpreloaded/cstenten23_mj2\t[lemma="jíst"]\n'
On line 57
[lemma="jíst"]
'Lemma "být" v minulém čase.\tpreloaded/cstenten23_mj2\t[lemma="být" & tag=".*mA.*"]\n'
On line 58
[ lemma="být" & tag="Vp.*" ]
'Vyhledej všechny tvary lemmatu "krásný".\tpreloaded/cstenten23_mj2\t[lemma="krásný"]\n'
On line 59
[lemma="krásný"]
'Slovo "kočka" ve všech pádech a číslech.\tpreloaded/cstenten23_mj2\t[lemma="kočka"]\n'
On line 60
[lemma="kočka"]
'Najdi všechna slova začínající na "ne" a končící na "ný".\tpreloaded/cstenten23_mj2\t[word="ne.*ný"]\n'
On line 61
[lc="ne.*ný"]
'Všechna slova, která mají uprostřed „stav“.\tpreloaded/cstenten23_mj2\t[word=".*stav.*"]\n'
On line 62
[lc=".+stav.+"]
'Všechna slova s předponou "pro-" a příponou \'-ní\'.\tpreloaded/cstenten23_mj2\t[lemma="pro.*ní"]\n'
On line 63
[word="^pro.*ní$"]
'Podstatná jména, která končí na „ka“.\tpreloaded/cstenten23_mj2\t[tag="k1.*" & word=".*ka"]\n'
On line 64
[ tag="N.*" & word=".*ka" ]
'Najdi výskyty číslovek v textu.\tpreloaded/cstenten23_mj2\t[tag="k4.*"]\n'
On line 65
[tag="C.*"]
'Najdi výskyty číslovek v textu.\tpreloaded/frtenten22_fl4\t[tag="Z.*"]\n'
On line 66
[tag="Z.*"]
'Najdi výskyty číslovek v textu.\tpreloaded/ententen21_tt31\t[tag="CD"]\n'
On line 67
[tag="CD" | tag="CDZ"]
'Všechny výskyty dvojtečky.\tpreloaded/cstenten23_mj2\t[word==":"]\n'
On line 68
[word=":"]
'Všechna interpunkční znaménka kromě tečky.\tpreloaded/cstenten23_mj2\t[tag="kI.*" & word!=="."]\n'
On line 69
[tag="Z.*" & word!="."]
'Najdi všechna podstatná jména v 1. pádě jednotného čísla.\tpreloaded/cstenten23_mj2\t[tag="k1.*nS.*c1.*"]\n'
On line 70
[tag="N.*S1.*"]
'Najdi všechny výpustky.\tpreloaded/cstenten23_mj2\t[word="\\.{3}"]\n'
On line 71
([word="\\.\\.\\."] | [word="…"])
'Najdi všechny výskyty zkratek (např. „např.“, „tj.“, „atd.“).\tpreloaded/cstenten23_mj2\t[tag="kA.*"]\n'
On line 72
[word=".*\\." & word!="."]
'Najdi všechny výskyty zkratek.\tpreloaded/cstenten23_mj2\t[tag="kA.*"]\n'
On line 73
[word="[A-Z]{2,}"]
'Najdi všechna slova obsahující pomlčku nebo spojovník.\tpreloaded/cstenten23_mj2\t[word=".*[-–].*"]\n'
On line 74
[word=".*-.*"]
'Najdi všechna slova, která mají stejný základ jako „věřit“.\tpreloaded/cstenten23_mj2\t[lemma="věřit"]\n'
On line 75
[lemma="věřit"]
'Potřebuji všechny předložky v korpusu.\tpreloaded/cstenten23_mj2\t[tag="k7.*"]\n'
On line 76
[tag="R.*"]
'Potřebuji nalézt příslovce.\tpreloaded/ententen21_tt31\t[tag="RB.*"]\n'
On line 77
[tag="RB.?"]
'Potřebuji nalézt příslovce.\tpreloaded/frtenten22_fl4\t[tag="R.*"]\n'
On line 78
[tag="R.*"]
'Potřebuji nalézt příslovce.\tpreloaded/cstenten23_mj2\t[tag="k6.*"]\n'
On line 79
[tag="D.*"]
'Chci slovo, které se v korpusu nachází na pozici 1000.\tpreloaded/ententen21_tt31\t[#1000]\n'
On line 80
1000:[]
'Potřebuji slovko, které se v korpusu nachází na první pozici.\tpreloaded/ententen21_tt31\t[#1]\n'
On line 81
<doc> []
'Jak naleznu slovo na pozici 7831?\tpreloaded/ententen21_tt31\t[#7831]\n'
On line 82
[] {7830} [ ]
'Slovo "COVID" po roce 2019\tpreloaded/ententen21_tt31\t[word="COVID"] within <doc year="20[2-9].*"/>\n'
On line 83
<doc crawl_year> [word="COVID"] & doc.crawl_year >= 2020
<doc> [word="COVID"] & doc.crawl_year >= 2020
<doc> 1:[word="COVID"] & doc.crawl_year >= 2020
<doc> 1:[word="COVID"] & (doc.crawl_year >= 2020)
'Potřebuji všechy výskyty různých květin vyskytující se v okolí velikosti +-5 od slova roste.\tpreloaded/ententen21_tt31\t(meet ~"dandelion-n" [lemma="grow"] -5 5)\n'
On line 84
(meet [lemma_lc="rose|tulip|daisy|lily|orchid|sunflower|violet|marigold|chrysanthemum|lavender|poppy|iris|geranium|begonia|azalea|hydrangea|peony|carnation|daffodil"] [lc="roste"] -5 5)
'Potřebuji všechy výskyty slova "grow" vyskytující se v okolí velikosti +-5 od různých květin.\tpreloaded/ententen21_tt31\t(meet [lemma="grow"] ~"dandelion-n" -5 5)\n'
On line 85
(meet [lemma="grow"] [lemma="(rose|tulip|daisy|lily|orchid|sunflower|daffodil|iris|lavender|marigold|poppy|violet|carnation|gardenia|hibiscus|jasmine|magnolia|peony|zinnia)"] -5 5)
'Najdi všechny případy, kdy je v přímé řeči oslovení.\tpreloaded/ententen21_tt31\t[word="\\""][word!="\\""]+[word="\\""] containing [word="\\""][tag="NP|NPS"][word=","][]?[tag="PP"]\n'
On line 86
([lemma_lc="you"] | ([tag="NP"] [word=","]) | ([tag="NPS"] [word=","])) within <quote/>
[word="\\\""] []{0,10} ( [lemma_lc="you"] | ([tag="NP"] [word=","]) | ([tag="NPS"] [word=","]) )
'Najdi všechny případy přímé řeči, kterou někdo pronáší.\tpreloaded/ententen21_tt31\t[word="\\""][word!="\\""]+[word="\\""] within (([tag="NP|NPS|PP"][lemma="say"][word=":"]?[word="\\""][word!="\\""]+[word="\\""]) | ([word="\\""][word!="\\""]+[word="\\""][lemma="say"][tag="NP|NPS|PP"]) | ([word="\\""][word!="\\""]+[word="\\""][tag="NP|NPS|PP"][lemma="say"]))\n'
On line 87
( [lemma="say"] | [lemma="tell"] | [lemma="ask"] | [lemma="reply"] | [lemma="exclaim"] | [lemma="state"] | [lemma="mention"] ) []{0,5} [tag="SYM" & word="\""]
'Najdi všechny věty, které jsou prosbou.\tpreloaded/ententen21_tt31\t<s/> containing ([lemma="please"] | [lemma="could"] | [lemma="would"] | [lemma="can"] | [lemma="will"] within <s/>)\n'
On line 88
(union ( <s/> [word="please"] []{0,5} [tag="VV"] ) ( <s/> [tag="VV"] ))
(union (<s/> containing [word="please"] []{0,5} [tag="VV"])       (<s/> containing [tag="VV"]))
(union ([word="please"] []{0,5} [tag="VV"] containing <s/>)       ([tag="VV"] containing <s/>))
<s/> containing ([word="please"]? []{0,5} [tag="VV"])
'Potřebuji všechy výskyty slova koroze vyskytující se okolo kovů.\tpreloaded/ententen21_tt31\t(meet [lemma="corrosion"] ~"metal-n" -5 5)\n'
On line 89
(meet [lemma="corrosion"] [lemma="(iron|steel|copper|aluminum|metal|metals)"] -5 5)
'Potřebuji všechy výskyty slova koroze vyskytující se okolo různých kovů. Použí thesaurus.\tpreloaded/ententen21_tt31\t(meet [lemma="corrosion"] ~"metal-n" -5 5)\n'
On line 90
(meet [lemma="corrosion"] ~"metal-n" -5 5)
(meet ~"metal-n" [lemma="corrosion"] -5 5)
(union ( [lemma="corrosion"] []{0,5} ~"metal-n" )       ( ~"metal-n" []{0,5} [lemma="corrosion"] ))
(meet [lemma="corrosion"] ~"metal-n" -5 5)
'Potřebuji všechy výskyty různých kovů vyskytující se okolo slova koroze.\tpreloaded/ententen21_tt31\t(meet ~"metal-n" [lemma="corrosion"] -5 5)\n'
On line 91
(meet ~"metal-n" [lemma="corrosion"] -5 5)
(meet [lemma="corrosion"] ~"metal-n" -5 5)
([lemma="corrosion"] []{0,5} ~"metal-n") | (~"metal-n" []{0,5} [lemma="corrosion"])
(union ( [lemma="corrosion"] []{0,5} ~"metal-n" ) ( ~"metal-n" []{0,5} [lemma="corrosion"] ))
'Potřebuji všechy výskyty slova koroze vyskytující se okolo různých květin.\tpreloaded/ententen21_tt31\t(meet [lemma="corrosion"] ~"daisy-n" -5 5)\n'
On line 92
(meet [lemma_lc="koroze"] [lemma_lc="(rose|tulip|daisy|lily|orchid|sunflower|marigold|lavender|poppy|iris|daffodil|carnation|geranium|begonia|azalea|hydrangea|violet|peony|chrysanthemum)"] -5 5)
'Potřebuji všechy výskyty slova roste vyskytující se v okolí velikosti +-5 od různých květin.\tpreloaded/ententen21_tt31\t(meet [lemma="grow"] ~"rose-n" -5 5)\n'
On line 93
(meet [word="roste"] [lemma="rose|tulip|daisy|lily|orchid|sunflower|dandelion|marigold|lavender|iris|poppy|carnation|violet|begonia|geranium|azalea|magnolia|peony|chrysanthemum"] -5 5)
